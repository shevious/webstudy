{"version":3,"file":"static/development/pages/vertical.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/assign.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/define-property.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/get-own-property-symbols.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/object/keys.js","webpack:///./node_modules/@babel/runtime-corejs2/core-js/parse-int.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/extends.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/objectWithoutProperties.js","webpack:///./node_modules/@babel/runtime-corejs2/helpers/esm/objectWithoutPropertiesLoose.js","webpack:///./pages/SwipeableViews.js","webpack:///./pages/vertical.js","webpack:///external \"core-js/library/fn/object/assign\"","webpack:///external \"core-js/library/fn/object/define-property\"","webpack:///external \"core-js/library/fn/object/get-own-property-symbols\"","webpack:///external \"core-js/library/fn/object/keys\"","webpack:///external \"core-js/library/fn/parse-int\"","webpack:///external \"dom-helpers/events/off\"","webpack:///external \"dom-helpers/events/on\"","webpack:///external \"dom-helpers/transition/properties\"","webpack:///external \"prop-types\"","webpack:///external \"react\"","webpack:///external \"react-swipeable-views-core\"","webpack:///external \"warning\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = require('../../../ssr-module-cache.js');\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tvar threw = true;\n \t\ttry {\n \t\t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n \t\t\tthrew = false;\n \t\t} finally {\n \t\t\tif(threw) delete installedModules[moduleId];\n \t\t}\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"core-js/library/fn/object/assign\");","module.exports = require(\"core-js/library/fn/object/define-property\");","module.exports = require(\"core-js/library/fn/object/get-own-property-symbols\");","module.exports = require(\"core-js/library/fn/object/keys\");","module.exports = require(\"core-js/library/fn/parse-int\");","import _Object$defineProperty from \"../../core-js/object/define-property\";\nexport default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    _Object$defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import _Object$assign from \"../../core-js/object/assign\";\nexport default function _extends() {\n  _extends = _Object$assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import _Object$getOwnPropertySymbols from \"../../core-js/object/get-own-property-symbols\";\nimport objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (_Object$getOwnPropertySymbols) {\n    var sourceSymbolKeys = _Object$getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","import _Object$keys from \"../../core-js/object/keys\";\nexport default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n\n  var sourceKeys = _Object$keys(source);\n\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import React from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport transitionInfo from 'dom-helpers/transition/properties';\nimport addEventListener from 'dom-helpers/events/on';\nimport removeEventListener from 'dom-helpers/events/off';\nimport {\n  constant,\n  checkIndexBounds,\n  computeIndex,\n  getDisplaySameSlide,\n} from 'react-swipeable-views-core';\n\nfunction addEventListenerEnhanced(node, event, handler, options) {\n  addEventListener(node, event, handler, options);\n  return {\n    remove() {\n      removeEventListener(node, event, handler, options);\n    },\n  };\n}\n\nconst styles = {\n  container: {\n    direction: 'ltr',\n    display: 'flex',\n    willChange: 'transform',\n  },\n  slide: {\n    width: '100%',\n    WebkitFlexShrink: 0,\n    flexShrink: 0,\n    overflow: 'auto',\n  },\n};\n\nconst axisProperties = {\n  root: {\n    x: {\n      overflowX: 'hidden',\n    },\n    'x-reverse': {\n      overflowX: 'hidden',\n    },\n    y: {\n      overflowY: 'hidden',\n    },\n    'y-reverse': {\n      overflowY: 'hidden',\n    },\n  },\n  flexDirection: {\n    x: 'row',\n    'x-reverse': 'row-reverse',\n    y: 'column',\n    'y-reverse': 'column-reverse',\n  },\n  transform: {\n    x: translate => `translate(${-translate}%, 0)`,\n    'x-reverse': translate => `translate(${translate}%, 0)`,\n    y: translate => `translate(0, ${-translate}%)`,\n    'y-reverse': translate => `translate(0, ${translate}%)`,\n  },\n  length: {\n    x: 'width',\n    'x-reverse': 'width',\n    y: 'height',\n    'y-reverse': 'height',\n  },\n  rotationMatrix: {\n    x: {\n      x: [1, 0],\n      y: [0, 1],\n    },\n    'x-reverse': {\n      x: [-1, 0],\n      y: [0, 1],\n    },\n    y: {\n      x: [0, 1],\n      y: [1, 0],\n    },\n    'y-reverse': {\n      x: [0, -1],\n      y: [1, 0],\n    },\n  },\n  scrollPosition: {\n    x: 'scrollLeft',\n    'x-reverse': 'scrollLeft',\n    y: 'scrollTop',\n    'y-reverse': 'scrollTop',\n  },\n  scrollLength: {\n    x: 'scrollWidth',\n    'x-reverse': 'scrollWidth',\n    y: 'scrollHeight',\n    'y-reverse': 'scrollHeight',\n  },\n  clientLength: {\n    x: 'clientWidth',\n    'x-reverse': 'clientWidth',\n    y: 'clientHeight',\n    'y-reverse': 'clientHeight',\n  },\n};\n\nfunction createTransition(property, options) {\n  const { duration, easeFunction, delay } = options;\n\n  return `${property} ${duration} ${easeFunction} ${delay}`;\n}\n\n// We are using a 2x2 rotation matrix.\nfunction applyRotationMatrix(touch, axis) {\n  const rotationMatrix = axisProperties.rotationMatrix[axis];\n\n  return {\n    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\n    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY,\n  };\n}\n\nfunction adaptMouse(event) {\n  event.touches = [{ pageX: event.pageX, pageY: event.pageY }];\n  return event;\n}\n\nexport function getDomTreeShapes(element, rootNode) {\n  let domTreeShapes = [];\n\n  while (element && element !== rootNode) {\n    // We reach a Swipeable View, no need to look higher in the dom tree.\n    if (element.hasAttribute('data-swipeable')) {\n      break;\n    }\n\n    const style = window.getComputedStyle(element);\n\n    if (\n      // Ignore the scroll children if the element is absolute positioned.\n      style.getPropertyValue('position') === 'absolute' ||\n      // Ignore the scroll children if the element has an overflowX hidden\n      style.getPropertyValue('overflow-x') === 'hidden'\n    ) {\n      domTreeShapes = [];\n    } else if (\n      (element.clientWidth > 0 && element.scrollWidth > element.clientWidth) ||\n      (element.clientHeight > 0 && element.scrollHeight > element.clientHeight)\n    ) {\n      // Ignore the nodes that have no width.\n      // Keep elements with a scroll\n      domTreeShapes.push({\n        element,\n        scrollWidth: element.scrollWidth,\n        scrollHeight: element.scrollHeight,\n        clientWidth: element.clientWidth,\n        clientHeight: element.clientHeight,\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop,\n      });\n    }\n\n    element = element.parentNode;\n  }\n\n  return domTreeShapes;\n}\n\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\nlet nodeWhoClaimedTheScroll = null;\n\nexport function findNativeHandler(params) {\n  const { domTreeShapes, pageX, startX, axis } = params;\n\n  return domTreeShapes.some(shape => {\n    // Determine if we are going backward or forward.\n    let goingForward = pageX >= startX;\n    if (axis === 'x' || axis === 'y') {\n      goingForward = !goingForward;\n    }\n\n    const scrollPosition = shape[axisProperties.scrollPosition[axis]];\n\n    const areNotAtStart = scrollPosition > 0;\n    const areNotAtEnd =\n      scrollPosition + shape[axisProperties.clientLength[axis]] <\n      shape[axisProperties.scrollLength[axis]];\n\n    if ((goingForward && areNotAtEnd) || (!goingForward && areNotAtStart)) {\n      nodeWhoClaimedTheScroll = shape.element;\n      return true;\n    }\n\n    return false;\n  });\n}\n\nclass SwipeableViews extends React.Component {\n  rootNode = null;\n\n  containerNode = null;\n\n  ignoreNextScrollEvents = false;\n\n  viewLength = 0;\n\n  startX = 0;\n\n  lastX = 0;\n\n  vx = 0;\n\n  startY = 0;\n\n  isSwiping = undefined;\n\n  started = false;\n\n  startIndex = 0;\n\n  transitionListener = null;\n\n  touchMoveListener = null;\n\n  activeSlide = null;\n\n  indexCurrent = null;\n\n  firstRenderTimeout = null;\n\n  constructor(props) {\n    super(props);\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkIndexBounds(props);\n    }\n\n    this.state = {\n      indexLatest: props.index,\n      // Set to true as soon as the component is swiping.\n      // It's the state counter part of this.isSwiping.\n      isDragging: false,\n      // Help with SSR logic and lazy loading logic.\n      renderOnlyActive: !props.disableLazyLoading,\n      heightLatest: 0,\n      // Let the render method that we are going to display the same slide than previously.\n      displaySameSlide: true,\n    };\n    this.setIndexCurrent(props.index);\n  }\n\n  getChildContext() {\n    return {\n      swipeableViews: {\n        slideUpdateHeight: () => {\n          this.updateHeight();\n        },\n      },\n    };\n  }\n\n  componentDidMount() {\n    // Subscribe to transition end events.\n    this.transitionListener = addEventListenerEnhanced(\n      this.containerNode,\n      transitionInfo.end,\n      event => {\n        if (event.target !== this.containerNode) {\n          return;\n        }\n\n        this.handleTransitionEnd();\n      },\n    );\n\n    // Block the thread to handle that event.\n    this.touchMoveListener = addEventListenerEnhanced(\n      this.rootNode,\n      'touchmove',\n      event => {\n        // Handling touch events is disabled.\n        if (this.props.disabled) {\n          return;\n        }\n        this.handleSwipeMove(event);\n      },\n      {\n        passive: false,\n      },\n    );\n\n    if (!this.props.disableLazyLoading) {\n      this.firstRenderTimeout = setTimeout(() => {\n        this.setState({\n          renderOnlyActive: false,\n        });\n      }, 0);\n    }\n\n    // Send all functions in an object if action param is set.\n    if (this.props.action) {\n      this.props.action({\n        updateHeight: this.updateHeight,\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const { index } = nextProps;\n\n    if (typeof index === 'number' && index !== this.props.index) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkIndexBounds(nextProps);\n      }\n\n      this.setIndexCurrent(index);\n      this.setState({\n        // If true, we are going to change the children. We shoudn't animate it.\n        displaySameSlide: getDisplaySameSlide(this.props, nextProps),\n        indexLatest: index,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.transitionListener.remove();\n    this.touchMoveListener.remove();\n    clearTimeout(this.firstRenderTimeout);\n  }\n\n  setIndexCurrent(indexCurrent) {\n    if (!this.props.animateTransitions && this.indexCurrent !== indexCurrent) {\n      this.handleTransitionEnd();\n    }\n\n    this.indexCurrent = indexCurrent;\n\n    if (this.containerNode) {\n      const { axis } = this.props;\n      const transform = axisProperties.transform[axis](indexCurrent * 100);\n      this.containerNode.style.WebkitTransform = transform;\n      this.containerNode.style.transform = transform;\n    }\n  }\n\n  setRootNode = node => {\n    this.rootNode = node;\n  };\n\n  setContainerNode = node => {\n    this.containerNode = node;\n  };\n\n  setActiveSlide = node => {\n    this.activeSlide = node;\n    this.updateHeight();\n  };\n\n  handleSwipeStart = event => {\n    const { axis } = this.props;\n\n    const touch = applyRotationMatrix(event.touches[0], axis);\n\n    this.viewLength = this.rootNode.getBoundingClientRect()[axisProperties.length[axis]];\n    this.startX = touch.pageX;\n    this.lastX = touch.pageX;\n    this.vx = 0;\n    this.startY = touch.pageY;\n    this.isSwiping = undefined;\n    this.started = true;\n\n    const computedStyle = window.getComputedStyle(this.containerNode);\n    const transform =\n      computedStyle.getPropertyValue('-webkit-transform') ||\n      computedStyle.getPropertyValue('transform');\n\n    if (transform && transform !== 'none') {\n      const transformValues = transform\n        .split('(')[1]\n        .split(')')[0]\n        .split(',');\n      const rootStyle = window.getComputedStyle(this.rootNode);\n\n      const tranformNormalized = applyRotationMatrix(\n        {\n          pageX: parseInt(transformValues[4], 10),\n          pageY: parseInt(transformValues[5], 10),\n        },\n        axis,\n      );\n\n      this.startIndex =\n        -tranformNormalized.pageX /\n          (this.viewLength -\n            parseInt(rootStyle.paddingLeft, 10) -\n            parseInt(rootStyle.paddingRight, 10)) || 0;\n    }\n  };\n\n  handleSwipeMove = event => {\n    // The touch start event can be cancel.\n    // Makes sure we set a starting point.\n    if (!this.started) {\n      this.handleTouchStart(event);\n      return;\n    }\n    //console.log(\"handleSwipeMove\");\n\n    // We are not supposed to hanlde this touch move.\n    if (nodeWhoClaimedTheScroll !== null && nodeWhoClaimedTheScroll !== this.rootNode) {\n      return;\n    }\n\n    const { axis, children, ignoreNativeScroll, onSwitching, resistance } = this.props;\n    const touch = applyRotationMatrix(event.touches[0], axis);\n    //console.log(\"touch.pageX =\", touch.pageX, \" this.startX = \", this.startX);\n\n    // We don't know yet.\n    if (this.isSwiping === undefined) {\n      const dx = Math.abs(touch.pageX - this.startX);\n      const dy = Math.abs(touch.pageY - this.startY);\n\n      const isSwiping = dx > dy && dx > constant.UNCERTAINTY_THRESHOLD;\n\n      // We let the parent handle the scroll.\n      if (\n        !resistance &&\n        (axis === 'y' || axis === 'y-reverse') &&\n        ((this.indexCurrent === 0 && this.startX < touch.pageX) ||\n          (this.indexCurrent === React.Children.count(this.props.children) - 1 &&\n            this.startX > touch.pageX))\n      ) {\n        this.isSwiping = false;\n        return;\n      }\n\n      // We are likely to be swiping, let's prevent the scroll event.\n      if (dx > dy) {\n        event.preventDefault();\n      }\n\n      if (isSwiping === true || dy > constant.UNCERTAINTY_THRESHOLD) {\n        this.isSwiping = isSwiping;\n        this.startX = touch.pageX; // Shift the starting point.\n\n        return; // Let's wait the next touch event to move something.\n      }\n    }\n\n    if (this.isSwiping !== true) {\n      return;\n    }\n\n    // We are swiping, let's prevent the scroll event.\n    event.preventDefault();\n\n    // Low Pass filter.\n    this.vx = this.vx * 0.5 + (touch.pageX - this.lastX) * 0.5;\n    this.lastX = touch.pageX;\n\n    const { index, startX } = computeIndex({\n      children,\n      resistance,\n      pageX: touch.pageX,\n      startIndex: this.startIndex,\n      startX: this.startX,\n      viewLength: this.viewLength,\n    });\n\n    // Add support for native scroll elements.\n    if (nodeWhoClaimedTheScroll === null && !ignoreNativeScroll) {\n      //console.log(\"native scroll elements\");\n      const domTreeShapes = getDomTreeShapes(event.target, this.rootNode);\n      const hasFoundNativeHandler = findNativeHandler({\n        domTreeShapes,\n        startX: this.startX,\n        pageX: touch.pageX,\n        axis,\n      });\n\n      // We abort the touch move handler.\n      if (hasFoundNativeHandler) {\n        return;\n      }\n    }\n\n    // We are moving toward the edges.\n    if (startX) {\n      this.startX = startX;\n    } else if (nodeWhoClaimedTheScroll === null) {\n      nodeWhoClaimedTheScroll = this.rootNode;\n    }\n\n    this.setIndexCurrent(index);\n\n    const callback = () => {\n      if (onSwitching) {\n        onSwitching(index, 'move');\n      }\n    };\n\n    if (this.state.displaySameSlide || !this.state.isDragging) {\n      this.setState(\n        {\n          displaySameSlide: false,\n          isDragging: true,\n        },\n        callback,\n      );\n    }\n\n    callback();\n  };\n\n  handleSwipeEnd = () => {\n    nodeWhoClaimedTheScroll = null;\n\n    // The touch start event can be cancel.\n    // Makes sure that a starting point is set.\n    if (!this.started) {\n      return;\n    }\n\n    this.started = false;\n\n    if (this.isSwiping !== true) {\n      return;\n    }\n\n    const indexLatest = this.state.indexLatest;\n    const indexCurrent = this.indexCurrent;\n    const delta = indexLatest - indexCurrent;\n\n    let indexNew;\n\n    // Quick movement\n    if (Math.abs(this.vx) > this.props.threshold) {\n      if (this.vx > 0) {\n        indexNew = Math.floor(indexCurrent);\n      } else {\n        indexNew = Math.ceil(indexCurrent);\n      }\n    } else if (Math.abs(delta) > this.props.hysteresis) {\n      // Some hysteresis with indexLatest.\n      indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);\n    } else {\n      indexNew = indexLatest;\n    }\n\n    const indexMax = React.Children.count(this.props.children) - 1;\n\n    if (indexNew < 0) {\n      indexNew = 0;\n    } else if (indexNew > indexMax) {\n      indexNew = indexMax;\n    }\n\n    this.setIndexCurrent(indexNew);\n    this.setState(\n      {\n        indexLatest: indexNew,\n        isDragging: false,\n      },\n      () => {\n        if (this.props.onSwitching) {\n          this.props.onSwitching(indexNew, 'end');\n        }\n\n        if (this.props.onChangeIndex && indexNew !== indexLatest) {\n          this.props.onChangeIndex(indexNew, indexLatest, {\n            reason: 'swipe',\n          });\n        }\n\n        // Manually calling handleTransitionEnd in that case as isn't otherwise.\n        if (indexCurrent === indexLatest) {\n          this.handleTransitionEnd();\n        }\n      },\n    );\n  };\n\n  handleTouchStart = event => {\n    if (this.props.onTouchStart) {\n      this.props.onTouchStart(event);\n    }\n    this.handleSwipeStart(event);\n  };\n\n  handleTouchEnd = event => {\n    if (this.props.onTouchEnd) {\n      this.props.onTouchEnd(event);\n    }\n    this.handleSwipeEnd(event);\n  };\n\n  handleMouseDown = event => {\n    if (this.props.onMouseDown) {\n      this.props.onMouseDown(event);\n    }\n    event.persist();\n    this.handleSwipeStart(adaptMouse(event));\n  };\n\n  handleMouseUp = event => {\n    if (this.props.onMouseUp) {\n      this.props.onMouseUp(event);\n    }\n    this.handleSwipeEnd(adaptMouse(event));\n  };\n\n  handleMouseLeave = event => {\n    if (this.props.onMouseLeave) {\n      this.props.onMouseLeave(event);\n    }\n\n    // Filter out events\n    if (this.started) {\n      this.handleSwipeEnd(adaptMouse(event));\n    }\n  };\n\n  handleMouseMove = event => {\n    if (this.props.onMouseMove) {\n      this.props.onMouseMove(event);\n    }\n\n    // Filter out events\n    if (this.started) {\n      this.handleSwipeMove(adaptMouse(event));\n    }\n  };\n\n  handleScroll = event => {\n    if (this.props.onScroll) {\n      this.props.onScroll(event);\n    }\n\n    // Ignore events bubbling up.\n    if (event.target !== this.rootNode) {\n      return;\n    }\n\n    if (this.ignoreNextScrollEvents) {\n      this.ignoreNextScrollEvents = false;\n      return;\n    }\n\n    const indexLatest = this.state.indexLatest;\n    const indexNew = Math.ceil(event.target.scrollLeft / event.target.clientWidth) + indexLatest;\n\n    this.ignoreNextScrollEvents = true;\n    // Reset the scroll position.\n    event.target.scrollLeft = 0;\n\n    if (this.props.onChangeIndex && indexNew !== indexLatest) {\n      this.props.onChangeIndex(indexNew, indexLatest, {\n        reason: 'focus',\n      });\n    }\n  };\n\n  updateHeight = () => {\n    if (this.activeSlide !== null) {\n      const child = this.activeSlide.children[0];\n      if (\n        child !== undefined &&\n        child.offsetHeight !== undefined &&\n        this.state.heightLatest !== child.offsetHeight\n      ) {\n        this.setState({\n          heightLatest: child.offsetHeight,\n        });\n      }\n    }\n  };\n\n  handleTransitionEnd() {\n    if (!this.props.onTransitionEnd) {\n      return;\n    }\n\n    // Filters out when changing the children\n    if (this.state.displaySameSlide) {\n      return;\n    }\n\n    // The rest callback is triggered when swiping. It's just noise.\n    // We filter it out.\n    if (!this.state.isDragging) {\n      this.props.onTransitionEnd();\n    }\n  }\n\n  render() {\n    const {\n      action,\n      animateHeight,\n      animateTransitions,\n      axis,\n      children,\n      containerStyle: containerStyleProp,\n      disabled,\n      disableLazyLoading,\n      enableMouseEvents,\n      hysteresis,\n      ignoreNativeScroll,\n      index,\n      onChangeIndex,\n      onSwitching,\n      onTransitionEnd,\n      resistance,\n      slideStyle: slideStyleProp,\n      slideClassName,\n      springConfig,\n      style,\n      threshold,\n      ...other\n    } = this.props;\n\n    const {\n      displaySameSlide,\n      heightLatest,\n      indexLatest,\n      isDragging,\n      renderOnlyActive,\n    } = this.state;\n    const touchEvents = !disabled\n      ? {\n          onTouchStart: this.handleTouchStart,\n          onTouchEnd: this.handleTouchEnd,\n        }\n      : {};\n    const mouseEvents =\n      !disabled && enableMouseEvents\n        ? {\n            onMouseDown: this.handleMouseDown,\n            onMouseUp: this.handleMouseUp,\n            onMouseLeave: this.handleMouseLeave,\n            onMouseMove: this.handleMouseMove,\n          }\n        : {};\n\n    // There is no point to animate if we are already providing a height.\n    warning(\n      !animateHeight || !containerStyleProp || !containerStyleProp.height,\n      `react-swipeable-view: You are setting animateHeight to true but you are\nalso providing a custom height.\nThe custom height has a higher priority than the animateHeight property.\nSo animateHeight is most likely having no effect at all.`,\n    );\n\n    const slideStyle = Object.assign({}, styles.slide, slideStyleProp);\n\n    let transition;\n    let WebkitTransition;\n\n    if (isDragging || !animateTransitions || displaySameSlide) {\n      transition = 'all 0s ease 0s';\n      WebkitTransition = 'all 0s ease 0s';\n    } else {\n      transition = createTransition('transform', springConfig);\n      WebkitTransition = createTransition('-webkit-transform', springConfig);\n\n      if (heightLatest !== 0) {\n        const additionalTranstion = `, ${createTransition('height', springConfig)}`;\n        transition += additionalTranstion;\n        WebkitTransition += additionalTranstion;\n      }\n    }\n\n    const containerStyle = {\n      height: null,\n      WebkitFlexDirection: axisProperties.flexDirection[axis],\n      flexDirection: axisProperties.flexDirection[axis],\n      WebkitTransition,\n      transition,\n    };\n\n    // Apply the styles for SSR considerations\n    if (!renderOnlyActive) {\n      const transform = axisProperties.transform[axis](this.indexCurrent * 100);\n      containerStyle.WebkitTransform = transform;\n      containerStyle.transform = transform;\n    }\n\n    if (animateHeight) {\n      containerStyle.height = heightLatest;\n    }\n\n    return (\n      <div\n        ref={this.setRootNode}\n        style={Object.assign({}, axisProperties.root[axis], style)}\n        {...other}\n        {...touchEvents}\n        {...mouseEvents}\n        onScroll={this.handleScroll}\n      >\n        <div\n          ref={this.setContainerNode}\n          style={Object.assign({}, containerStyle, styles.container, containerStyleProp)}\n          className=\"react-swipeable-view-container\"\n        >\n          {React.Children.map(children, (child, indexChild) => {\n            if (renderOnlyActive && indexChild !== indexLatest) {\n              return null;\n            }\n\n            //console.log(\"indexChild =\", indexChild); \n\n            warning(\n              React.isValidElement(child),\n              `react-swipeable-view: one of the children provided is invalid: ${child}.\nWe are expecting a valid React Element`,\n            );\n\n            let ref;\n            let hidden = true;\n\n            if (indexChild === indexLatest) {\n              hidden = false;\n\n              if (animateHeight) {\n                ref = this.setActiveSlide;\n                slideStyle.overflowY = 'hidden';\n              }\n            }\n\n            return (\n              <div\n                ref={ref}\n                style={slideStyle}\n                className={slideClassName}\n                aria-hidden={hidden}\n                data-swipeable=\"true\"\n              >\n                {child}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\n// Added as an ads for people using the React dev tools in production.\n// So they know, the tool used to build the awesome UI they\n// are looking at/retro engineering.\nSwipeableViews.displayName = 'ReactSwipableView';\n\nSwipeableViews.propTypes = {\n  /**\n   * This is callback property. It's called by the component on mount.\n   * This is useful when you want to trigger an action programmatically.\n   * It currently only supports updateHeight() action.\n   *\n   * @param {object} actions This object contains all posible actions\n   * that can be triggered programmatically.\n   */\n  action: PropTypes.func,\n  /**\n   * If `true`, the height of the container will be animated to match the current slide height.\n   * Animating another style property has a negative impact regarding performance.\n   */\n  animateHeight: PropTypes.bool,\n  /**\n   * If `false`, changes to the index prop will not cause an animated transition.\n   */\n  animateTransitions: PropTypes.bool,\n  /**\n   * The axis on which the slides will slide.\n   */\n  axis: PropTypes.oneOf(['x', 'x-reverse', 'y', 'y-reverse']),\n  /**\n   * Use this property to provide your slides.\n   */\n  children: PropTypes.node.isRequired,\n  /**\n   * This is the inlined style that will be applied\n   * to each slide container.\n   */\n  containerStyle: PropTypes.object,\n  /**\n   * If `true`, it will disable touch events.\n   * This is useful when you want to prohibit the user from changing slides.\n   */\n  disabled: PropTypes.bool,\n  /**\n   * This is the config used to disable lazyloding,\n   * if `true` will render all the views in first rendering.\n   */\n  disableLazyLoading: PropTypes.bool,\n  /**\n   * If `true`, it will enable mouse events.\n   * This will allow the user to perform the relevant swipe actions with a mouse.\n   */\n  enableMouseEvents: PropTypes.bool,\n  /**\n   * Configure hysteresis between slides. This value determines how far\n   * should user swipe to switch slide.\n   */\n  hysteresis: PropTypes.number,\n  /**\n   * If `true`, it will ignore native scroll container.\n   * It can be used to filter out false positive that blocks the swipe.\n   */\n  ignoreNativeScroll: PropTypes.bool,\n  /**\n   * This is the index of the slide to show.\n   * This is useful when you want to change the default slide shown.\n   * Or when you have tabs linked to each slide.\n   */\n  index: PropTypes.number,\n  /**\n   * This is callback prop. It's call by the\n   * component when the shown slide change after a swipe made by the user.\n   * This is useful when you have tabs linked to each slide.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {integer} indexLatest This is the oldest index of the slide.\n   * @param {object} meta Meta data containing more information about the event.\n   */\n  onChangeIndex: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseDown: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseLeave: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseMove: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseUp: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onScroll: PropTypes.func,\n  /**\n   * This is callback prop. It's called by the\n   * component when the slide switching.\n   * This is useful when you want to implement something corresponding\n   * to the current slide position.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {string} type Can be either `move` or `end`.\n   */\n  onSwitching: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchEnd: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchMove: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchStart: PropTypes.func,\n  /**\n   * The callback that fires when the animation comes to a rest.\n   * This is useful to defer CPU intensive task.\n   */\n  onTransitionEnd: PropTypes.func,\n  /**\n   * If `true`, it will add bounds effect on the edges.\n   */\n  resistance: PropTypes.bool,\n  /**\n   * This is the className that will be applied\n   * on the slide component.\n   */\n  slideClassName: PropTypes.string,\n  /**\n   * This is the inlined style that will be applied\n   * on the slide component.\n   */\n  slideStyle: PropTypes.object,\n  /**\n   * This is the config used to create CSS transitions.\n   * This is useful to change the dynamic of the transition.\n   */\n  springConfig: PropTypes.shape({\n    delay: PropTypes.string,\n    duration: PropTypes.string,\n    easeFunction: PropTypes.string,\n  }),\n  /**\n   * This is the inlined style that will be applied\n   * on the root component.\n   */\n  style: PropTypes.object,\n  /**\n   * This is the threshold used for detecting a quick swipe.\n   * If the computed speed is above this value, the index change.\n   */\n  threshold: PropTypes.number,\n};\n\nSwipeableViews.defaultProps = {\n  animateHeight: false,\n  animateTransitions: true,\n  axis: 'x',\n  disabled: false,\n  disableLazyLoading: false,\n  enableMouseEvents: false,\n  hysteresis: 0.6,\n  ignoreNativeScroll: false,\n  index: 0,\n  threshold: 5,\n  springConfig: {\n    duration: '0.35s',\n    easeFunction: 'cubic-bezier(0.15, 0.3, 0.25, 1)',\n    delay: '0s',\n  },\n  resistance: false,\n};\n\nSwipeableViews.childContextTypes = {\n  swipeableViews: PropTypes.shape({\n    slideUpdateHeight: PropTypes.func,\n  }),\n};\n\nexport default SwipeableViews;\n","//import React from 'react';\nimport SwipeableViews from './SwipeableViews.js';\n\nconst styles = {\n  slideContainer: {\n    height: 200,\n  },\n  slide: {\n    //padding: 15,\n    minHeight: 200,\n    color: '#fff',\n  },\n  slide1: {\n    backgroundColor: '#FEA900',\n  },\n  slide2: {\n    backgroundColor: '#B3DC4A',\n  },\n  slide3: {\n    backgroundColor: '#6AC0FF',\n  },\n};\n\n\nconst Vertical = () => {\n  return (\n    <SwipeableViews containerStyle={styles.slideContainer} enableMouseEvents axis=\"y\" resistance>\n      <div style={Object.assign({}, styles.slide, styles.slide1)}>slide n°1</div>\n      <div style={Object.assign({}, styles.slide, styles.slide2)}>slide n°2</div>\n      <div style={Object.assign({}, styles.slide, styles.slide3)}>slide n°3</div>\n    </SwipeableViews>\n  );\n};\n\nexport default Vertical;\n\n","module.exports = require(\"core-js/library/fn/object/assign\");","module.exports = require(\"core-js/library/fn/object/define-property\");","module.exports = require(\"core-js/library/fn/object/get-own-property-symbols\");","module.exports = require(\"core-js/library/fn/object/keys\");","module.exports = require(\"core-js/library/fn/parse-int\");","module.exports = require(\"dom-helpers/events/off\");","module.exports = require(\"dom-helpers/events/on\");","module.exports = require(\"dom-helpers/transition/properties\");","module.exports = require(\"prop-types\");","module.exports = require(\"react\");","module.exports = require(\"react-swipeable-views-core\");","module.exports = require(\"warning\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxFA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAJA;AANA;AAcA;AACA;AACA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAVA;AAcA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAbA;AAkBA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAJA;AA/DA;AACA;AAsEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiCA;AACA;AACA;AAFA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AADA;AAoHA;AACA;AACA;AAtHA;AAwHA;AACA;AACA;AA1HA;AA4HA;AACA;AACA;AACA;AA/HA;AAiIA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAIA;AAEA;AAEA;AACA;AAFA;AAOA;AAKA;AACA;AACA;AAxKA;AA0KA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AA3RA;AA6RA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA/VA;AAiWA;AACA;AACA;AACA;AAAA;AACA;AACA;AAtWA;AAwWA;AACA;AACA;AACA;AAAA;AACA;AACA;AA7WA;AA+WA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AArXA;AAuXA;AACA;AACA;AACA;AAAA;AACA;AACA;AA5XA;AA8XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvYA;AAyYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlZA;AAoZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AA/aA;AAibA;AACA;AACA;AAAA;AAKA;AACA;AADA;AAGA;AACA;AACA;AACA;AA3bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AADA;AAOA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AADA;AACA;AAIA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AA6UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAAA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AAFA;AAKA;AAGA;AACA;AACA;AACA;AAJA;AACA;AAQA;;;AAAA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAFA;AAMA;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAIA;AACA;AAxoBA;AA2oBA;AACA;AACA;AACA;AADA;AAEA;AACA;;;;;;;;AAQA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;AAGA;AACA;AAAA;;;AAGA;AACA;AAAA;;;AAGA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;;;AAKA;AACA;AAAA;;;;;;;;;AASA;AACA;AAAA;;;AAGA;AACA;AAAA;;;AAGA;AACA;AAAA;;;AAGA;AACA;AAAA;;;AAGA;AACA;AAAA;;;AAGA;AACA;AAAA;;;;;;;;;AASA;AACA;AAAA;;;AAGA;AACA;AAAA;;;AAGA;AACA;AAAA;;;AAGA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;AAGA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;;AAIA;AACA;AAAA;;;;AAIA;AACA;AACA;AACA;AAHA;AACA;AAIA;;;;AAIA;AACA;AAAA;;;;AAIA;AAxJA;AA2JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAhBA;AAmBA;AACA;AACA;AADA;AADA;AAMA;;;;;;;;;;;;;;;;;;;;;;AC3gCA;AACA;AAEA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AAHA;AAKA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAfA;AACA;AAoBA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AClCA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}