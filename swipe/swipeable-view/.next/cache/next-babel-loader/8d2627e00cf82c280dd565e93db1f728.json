{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport _parseInt from \"@babel/runtime-corejs2/core-js/parse-int\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/home/vagrant/webstudy/swipe/swipeable-view/pages/SwipeableViews.js\";\nvar __jsx = React.createElement;\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport transitionInfo from 'dom-helpers/transition/properties';\nimport addEventListener from 'dom-helpers/events/on';\nimport removeEventListener from 'dom-helpers/events/off';\nimport { constant, checkIndexBounds, computeIndex, getDisplaySameSlide } from 'react-swipeable-views-core';\n\nfunction addEventListenerEnhanced(node, event, handler, options) {\n  addEventListener(node, event, handler, options);\n  return {\n    remove() {\n      removeEventListener(node, event, handler, options);\n    }\n\n  };\n}\n\nconst styles = {\n  container: {\n    direction: 'ltr',\n    display: 'flex',\n    willChange: 'transform'\n  },\n  slide: {\n    width: '100%',\n    WebkitFlexShrink: 0,\n    flexShrink: 0,\n    overflow: 'auto'\n  }\n};\nconst axisProperties = {\n  root: {\n    x: {\n      overflowX: 'hidden'\n    },\n    'x-reverse': {\n      overflowX: 'hidden'\n    },\n    y: {\n      overflowY: 'hidden'\n    },\n    'y-reverse': {\n      overflowY: 'hidden'\n    }\n  },\n  flexDirection: {\n    x: 'row',\n    'x-reverse': 'row-reverse',\n    y: 'column',\n    'y-reverse': 'column-reverse'\n  },\n  transform: {\n    x: translate => `translate(${-translate}%, 0)`,\n    'x-reverse': translate => `translate(${translate}%, 0)`,\n    y: translate => `translate(0, ${-translate}%)`,\n    'y-reverse': translate => `translate(0, ${translate}%)`\n  },\n  length: {\n    x: 'width',\n    'x-reverse': 'width',\n    y: 'height',\n    'y-reverse': 'height'\n  },\n  rotationMatrix: {\n    x: {\n      x: [1, 0],\n      y: [0, 1]\n    },\n    'x-reverse': {\n      x: [-1, 0],\n      y: [0, 1]\n    },\n    y: {\n      x: [0, 1],\n      y: [1, 0]\n    },\n    'y-reverse': {\n      x: [0, -1],\n      y: [1, 0]\n    }\n  },\n  scrollPosition: {\n    x: 'scrollLeft',\n    'x-reverse': 'scrollLeft',\n    y: 'scrollTop',\n    'y-reverse': 'scrollTop'\n  },\n  scrollLength: {\n    x: 'scrollWidth',\n    'x-reverse': 'scrollWidth',\n    y: 'scrollHeight',\n    'y-reverse': 'scrollHeight'\n  },\n  clientLength: {\n    x: 'clientWidth',\n    'x-reverse': 'clientWidth',\n    y: 'clientHeight',\n    'y-reverse': 'clientHeight'\n  }\n};\n\nfunction createTransition(property, options) {\n  const {\n    duration,\n    easeFunction,\n    delay\n  } = options;\n  return `${property} ${duration} ${easeFunction} ${delay}`;\n} // We are using a 2x2 rotation matrix.\n\n\nfunction applyRotationMatrix(touch, axis) {\n  const rotationMatrix = axisProperties.rotationMatrix[axis];\n  return {\n    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\n    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY\n  };\n}\n\nfunction adaptMouse(event) {\n  event.touches = [{\n    pageX: event.pageX,\n    pageY: event.pageY\n  }];\n  return event;\n}\n\nexport function getDomTreeShapes(element, rootNode) {\n  let domTreeShapes = [];\n\n  while (element && element !== rootNode) {\n    // We reach a Swipeable View, no need to look higher in the dom tree.\n    if (element.hasAttribute('data-swipeable')) {\n      break;\n    }\n\n    const style = window.getComputedStyle(element);\n\n    if ( // Ignore the scroll children if the element is absolute positioned.\n    style.getPropertyValue('position') === 'absolute' || // Ignore the scroll children if the element has an overflowX hidden\n    style.getPropertyValue('overflow-x') === 'hidden') {\n      domTreeShapes = [];\n    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {\n      // Ignore the nodes that have no width.\n      // Keep elements with a scroll\n      domTreeShapes.push({\n        element,\n        scrollWidth: element.scrollWidth,\n        scrollHeight: element.scrollHeight,\n        clientWidth: element.clientWidth,\n        clientHeight: element.clientHeight,\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      });\n    }\n\n    element = element.parentNode;\n  }\n\n  return domTreeShapes;\n} // We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nlet nodeWhoClaimedTheScroll = null;\nexport function findNativeHandler(params) {\n  const {\n    domTreeShapes,\n    pageX,\n    startX,\n    axis\n  } = params;\n  return domTreeShapes.some(shape => {\n    // Determine if we are going backward or forward.\n    let goingForward = pageX >= startX;\n\n    if (axis === 'x' || axis === 'y') {\n      goingForward = !goingForward;\n    }\n\n    const scrollPosition = shape[axisProperties.scrollPosition[axis]];\n    const areNotAtStart = scrollPosition > 0;\n    const areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\n\n    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {\n      nodeWhoClaimedTheScroll = shape.element;\n      return true;\n    }\n\n    return false;\n  });\n}\n\nclass SwipeableViews extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"rootNode\", null);\n\n    _defineProperty(this, \"containerNode\", null);\n\n    _defineProperty(this, \"ignoreNextScrollEvents\", false);\n\n    _defineProperty(this, \"viewLength\", 0);\n\n    _defineProperty(this, \"startX\", 0);\n\n    _defineProperty(this, \"lastX\", 0);\n\n    _defineProperty(this, \"vx\", 0);\n\n    _defineProperty(this, \"startY\", 0);\n\n    _defineProperty(this, \"isSwiping\", undefined);\n\n    _defineProperty(this, \"started\", false);\n\n    _defineProperty(this, \"startIndex\", 0);\n\n    _defineProperty(this, \"transitionListener\", null);\n\n    _defineProperty(this, \"touchMoveListener\", null);\n\n    _defineProperty(this, \"activeSlide\", null);\n\n    _defineProperty(this, \"indexCurrent\", null);\n\n    _defineProperty(this, \"firstRenderTimeout\", null);\n\n    _defineProperty(this, \"setRootNode\", node => {\n      this.rootNode = node;\n    });\n\n    _defineProperty(this, \"setContainerNode\", node => {\n      this.containerNode = node;\n    });\n\n    _defineProperty(this, \"setActiveSlide\", node => {\n      this.activeSlide = node;\n      this.updateHeight();\n    });\n\n    _defineProperty(this, \"handleSwipeStart\", event => {\n      const {\n        axis\n      } = this.props;\n      const touch = applyRotationMatrix(event.touches[0], axis);\n      this.viewLength = this.rootNode.getBoundingClientRect()[axisProperties.length[axis]];\n      this.startX = touch.pageX;\n      this.lastX = touch.pageX;\n      this.vx = 0;\n      this.startY = touch.pageY;\n      this.isSwiping = undefined;\n      this.started = true;\n      const computedStyle = window.getComputedStyle(this.containerNode);\n      const transform = computedStyle.getPropertyValue('-webkit-transform') || computedStyle.getPropertyValue('transform');\n\n      if (transform && transform !== 'none') {\n        const transformValues = transform.split('(')[1].split(')')[0].split(',');\n        const rootStyle = window.getComputedStyle(this.rootNode);\n        const tranformNormalized = applyRotationMatrix({\n          pageX: _parseInt(transformValues[4], 10),\n          pageY: _parseInt(transformValues[5], 10)\n        }, axis);\n        this.startIndex = -tranformNormalized.pageX / (this.viewLength - _parseInt(rootStyle.paddingLeft, 10) - _parseInt(rootStyle.paddingRight, 10)) || 0;\n      }\n    });\n\n    _defineProperty(this, \"handleSwipeMove\", event => {\n      // The touch start event can be cancel.\n      // Makes sure we set a starting point.\n      if (!this.started) {\n        this.handleTouchStart(event);\n        return;\n      }\n\n      console.log(\"handleSwipeMove\"); // We are not supposed to hanlde this touch move.\n\n      if (nodeWhoClaimedTheScroll !== null && nodeWhoClaimedTheScroll !== this.rootNode) {\n        return;\n      }\n\n      const {\n        axis,\n        children,\n        ignoreNativeScroll,\n        onSwitching,\n        resistance\n      } = this.props;\n      const touch = applyRotationMatrix(event.touches[0], axis);\n      console.log(\"touch.pageX =\", touch.pageX, \" this.startX = \", this.startX); // We don't know yet.\n\n      if (this.isSwiping === undefined) {\n        const dx = Math.abs(touch.pageX - this.startX);\n        const dy = Math.abs(touch.pageY - this.startY);\n        const isSwiping = dx > dy && dx > constant.UNCERTAINTY_THRESHOLD; // We let the parent handle the scroll.\n\n        if (!resistance && (axis === 'y' || axis === 'y-reverse') && (this.indexCurrent === 0 && this.startX < touch.pageX || this.indexCurrent === React.Children.count(this.props.children) - 1 && this.startX > touch.pageX)) {\n          this.isSwiping = false;\n          return;\n        } // We are likely to be swiping, let's prevent the scroll event.\n\n\n        if (dx > dy) {\n          event.preventDefault();\n        }\n\n        if (isSwiping === true || dy > constant.UNCERTAINTY_THRESHOLD) {\n          this.isSwiping = isSwiping;\n          this.startX = touch.pageX; // Shift the starting point.\n\n          return; // Let's wait the next touch event to move something.\n        }\n      }\n\n      if (this.isSwiping !== true) {\n        return;\n      } // We are swiping, let's prevent the scroll event.\n\n\n      event.preventDefault(); // Low Pass filter.\n\n      this.vx = this.vx * 0.5 + (touch.pageX - this.lastX) * 0.5;\n      this.lastX = touch.pageX;\n      const {\n        index,\n        startX\n      } = computeIndex({\n        children,\n        resistance,\n        pageX: touch.pageX,\n        startIndex: this.startIndex,\n        startX: this.startX,\n        viewLength: this.viewLength\n      }); // Add support for native scroll elements.\n\n      if (nodeWhoClaimedTheScroll === null && !ignoreNativeScroll) {\n        console.log(\"native scroll elements\");\n        const domTreeShapes = getDomTreeShapes(event.target, this.rootNode);\n        const hasFoundNativeHandler = findNativeHandler({\n          domTreeShapes,\n          startX: this.startX,\n          pageX: touch.pageX,\n          axis\n        }); // We abort the touch move handler.\n\n        if (hasFoundNativeHandler) {\n          return;\n        }\n      } // We are moving toward the edges.\n\n\n      if (startX) {\n        this.startX = startX;\n      } else if (nodeWhoClaimedTheScroll === null) {\n        nodeWhoClaimedTheScroll = this.rootNode;\n      }\n\n      this.setIndexCurrent(index);\n\n      const callback = () => {\n        if (onSwitching) {\n          onSwitching(index, 'move');\n        }\n      };\n\n      if (this.state.displaySameSlide || !this.state.isDragging) {\n        this.setState({\n          displaySameSlide: false,\n          isDragging: true\n        }, callback);\n      }\n\n      callback();\n    });\n\n    _defineProperty(this, \"handleSwipeEnd\", () => {\n      nodeWhoClaimedTheScroll = null; // The touch start event can be cancel.\n      // Makes sure that a starting point is set.\n\n      if (!this.started) {\n        return;\n      }\n\n      this.started = false;\n\n      if (this.isSwiping !== true) {\n        return;\n      }\n\n      const indexLatest = this.state.indexLatest;\n      const indexCurrent = this.indexCurrent;\n      const delta = indexLatest - indexCurrent;\n      let indexNew; // Quick movement\n\n      if (Math.abs(this.vx) > this.props.threshold) {\n        if (this.vx > 0) {\n          indexNew = Math.floor(indexCurrent);\n        } else {\n          indexNew = Math.ceil(indexCurrent);\n        }\n      } else if (Math.abs(delta) > this.props.hysteresis) {\n        // Some hysteresis with indexLatest.\n        indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);\n      } else {\n        indexNew = indexLatest;\n      }\n\n      const indexMax = React.Children.count(this.props.children) - 1;\n\n      if (indexNew < 0) {\n        indexNew = 0;\n      } else if (indexNew > indexMax) {\n        indexNew = indexMax;\n      }\n\n      this.setIndexCurrent(indexNew);\n      this.setState({\n        indexLatest: indexNew,\n        isDragging: false\n      }, () => {\n        if (this.props.onSwitching) {\n          this.props.onSwitching(indexNew, 'end');\n        }\n\n        if (this.props.onChangeIndex && indexNew !== indexLatest) {\n          this.props.onChangeIndex(indexNew, indexLatest, {\n            reason: 'swipe'\n          });\n        } // Manually calling handleTransitionEnd in that case as isn't otherwise.\n\n\n        if (indexCurrent === indexLatest) {\n          this.handleTransitionEnd();\n        }\n      });\n    });\n\n    _defineProperty(this, \"handleTouchStart\", event => {\n      if (this.props.onTouchStart) {\n        this.props.onTouchStart(event);\n      }\n\n      this.handleSwipeStart(event);\n    });\n\n    _defineProperty(this, \"handleTouchEnd\", event => {\n      if (this.props.onTouchEnd) {\n        this.props.onTouchEnd(event);\n      }\n\n      this.handleSwipeEnd(event);\n    });\n\n    _defineProperty(this, \"handleMouseDown\", event => {\n      if (this.props.onMouseDown) {\n        this.props.onMouseDown(event);\n      }\n\n      event.persist();\n      this.handleSwipeStart(adaptMouse(event));\n    });\n\n    _defineProperty(this, \"handleMouseUp\", event => {\n      if (this.props.onMouseUp) {\n        this.props.onMouseUp(event);\n      }\n\n      this.handleSwipeEnd(adaptMouse(event));\n    });\n\n    _defineProperty(this, \"handleMouseLeave\", event => {\n      if (this.props.onMouseLeave) {\n        this.props.onMouseLeave(event);\n      } // Filter out events\n\n\n      if (this.started) {\n        this.handleSwipeEnd(adaptMouse(event));\n      }\n    });\n\n    _defineProperty(this, \"handleMouseMove\", event => {\n      if (this.props.onMouseMove) {\n        this.props.onMouseMove(event);\n      } // Filter out events\n\n\n      if (this.started) {\n        this.handleSwipeMove(adaptMouse(event));\n      }\n    });\n\n    _defineProperty(this, \"handleScroll\", event => {\n      if (this.props.onScroll) {\n        this.props.onScroll(event);\n      } // Ignore events bubbling up.\n\n\n      if (event.target !== this.rootNode) {\n        return;\n      }\n\n      if (this.ignoreNextScrollEvents) {\n        this.ignoreNextScrollEvents = false;\n        return;\n      }\n\n      const indexLatest = this.state.indexLatest;\n      const indexNew = Math.ceil(event.target.scrollLeft / event.target.clientWidth) + indexLatest;\n      this.ignoreNextScrollEvents = true; // Reset the scroll position.\n\n      event.target.scrollLeft = 0;\n\n      if (this.props.onChangeIndex && indexNew !== indexLatest) {\n        this.props.onChangeIndex(indexNew, indexLatest, {\n          reason: 'focus'\n        });\n      }\n    });\n\n    _defineProperty(this, \"updateHeight\", () => {\n      if (this.activeSlide !== null) {\n        const child = this.activeSlide.children[0];\n\n        if (child !== undefined && child.offsetHeight !== undefined && this.state.heightLatest !== child.offsetHeight) {\n          this.setState({\n            heightLatest: child.offsetHeight\n          });\n        }\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkIndexBounds(props);\n    }\n\n    this.state = {\n      indexLatest: props.index,\n      // Set to true as soon as the component is swiping.\n      // It's the state counter part of this.isSwiping.\n      isDragging: false,\n      // Help with SSR logic and lazy loading logic.\n      renderOnlyActive: !props.disableLazyLoading,\n      heightLatest: 0,\n      // Let the render method that we are going to display the same slide than previously.\n      displaySameSlide: true\n    };\n    this.setIndexCurrent(props.index);\n  }\n\n  getChildContext() {\n    return {\n      swipeableViews: {\n        slideUpdateHeight: () => {\n          this.updateHeight();\n        }\n      }\n    };\n  }\n\n  componentDidMount() {\n    // Subscribe to transition end events.\n    this.transitionListener = addEventListenerEnhanced(this.containerNode, transitionInfo.end, event => {\n      if (event.target !== this.containerNode) {\n        return;\n      }\n\n      this.handleTransitionEnd();\n    }); // Block the thread to handle that event.\n\n    this.touchMoveListener = addEventListenerEnhanced(this.rootNode, 'touchmove', event => {\n      // Handling touch events is disabled.\n      if (this.props.disabled) {\n        return;\n      }\n\n      this.handleSwipeMove(event);\n    }, {\n      passive: false\n    });\n\n    if (!this.props.disableLazyLoading) {\n      this.firstRenderTimeout = setTimeout(() => {\n        this.setState({\n          renderOnlyActive: false\n        });\n      }, 0);\n    } // Send all functions in an object if action param is set.\n\n\n    if (this.props.action) {\n      this.props.action({\n        updateHeight: this.updateHeight\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const {\n      index\n    } = nextProps;\n\n    if (typeof index === 'number' && index !== this.props.index) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkIndexBounds(nextProps);\n      }\n\n      this.setIndexCurrent(index);\n      this.setState({\n        // If true, we are going to change the children. We shoudn't animate it.\n        displaySameSlide: getDisplaySameSlide(this.props, nextProps),\n        indexLatest: index\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.transitionListener.remove();\n    this.touchMoveListener.remove();\n    clearTimeout(this.firstRenderTimeout);\n  }\n\n  setIndexCurrent(indexCurrent) {\n    if (!this.props.animateTransitions && this.indexCurrent !== indexCurrent) {\n      this.handleTransitionEnd();\n    }\n\n    this.indexCurrent = indexCurrent;\n\n    if (this.containerNode) {\n      const {\n        axis\n      } = this.props;\n      const transform = axisProperties.transform[axis](indexCurrent * 100);\n      this.containerNode.style.WebkitTransform = transform;\n      this.containerNode.style.transform = transform;\n    }\n  }\n\n  handleTransitionEnd() {\n    if (!this.props.onTransitionEnd) {\n      return;\n    } // Filters out when changing the children\n\n\n    if (this.state.displaySameSlide) {\n      return;\n    } // The rest callback is triggered when swiping. It's just noise.\n    // We filter it out.\n\n\n    if (!this.state.isDragging) {\n      this.props.onTransitionEnd();\n    }\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      action,\n      animateHeight,\n      animateTransitions,\n      axis,\n      children,\n      containerStyle: containerStyleProp,\n      disabled,\n      disableLazyLoading,\n      enableMouseEvents,\n      hysteresis,\n      ignoreNativeScroll,\n      index,\n      onChangeIndex,\n      onSwitching,\n      onTransitionEnd,\n      resistance,\n      slideStyle: slideStyleProp,\n      slideClassName,\n      springConfig,\n      style,\n      threshold\n    } = _this$props,\n          other = _objectWithoutProperties(_this$props, [\"action\", \"animateHeight\", \"animateTransitions\", \"axis\", \"children\", \"containerStyle\", \"disabled\", \"disableLazyLoading\", \"enableMouseEvents\", \"hysteresis\", \"ignoreNativeScroll\", \"index\", \"onChangeIndex\", \"onSwitching\", \"onTransitionEnd\", \"resistance\", \"slideStyle\", \"slideClassName\", \"springConfig\", \"style\", \"threshold\"]);\n\n    const {\n      displaySameSlide,\n      heightLatest,\n      indexLatest,\n      isDragging,\n      renderOnlyActive\n    } = this.state;\n    const touchEvents = !disabled ? {\n      onTouchStart: this.handleTouchStart,\n      onTouchEnd: this.handleTouchEnd\n    } : {};\n    const mouseEvents = !disabled && enableMouseEvents ? {\n      onMouseDown: this.handleMouseDown,\n      onMouseUp: this.handleMouseUp,\n      onMouseLeave: this.handleMouseLeave,\n      onMouseMove: this.handleMouseMove\n    } : {}; // There is no point to animate if we are already providing a height.\n\n    warning(!animateHeight || !containerStyleProp || !containerStyleProp.height, `react-swipeable-view: You are setting animateHeight to true but you are\nalso providing a custom height.\nThe custom height has a higher priority than the animateHeight property.\nSo animateHeight is most likely having no effect at all.`);\n\n    const slideStyle = _Object$assign({}, styles.slide, slideStyleProp);\n\n    let transition;\n    let WebkitTransition;\n\n    if (isDragging || !animateTransitions || displaySameSlide) {\n      transition = 'all 0s ease 0s';\n      WebkitTransition = 'all 0s ease 0s';\n    } else {\n      transition = createTransition('transform', springConfig);\n      WebkitTransition = createTransition('-webkit-transform', springConfig);\n\n      if (heightLatest !== 0) {\n        const additionalTranstion = `, ${createTransition('height', springConfig)}`;\n        transition += additionalTranstion;\n        WebkitTransition += additionalTranstion;\n      }\n    }\n\n    const containerStyle = {\n      height: null,\n      WebkitFlexDirection: axisProperties.flexDirection[axis],\n      flexDirection: axisProperties.flexDirection[axis],\n      WebkitTransition,\n      transition\n    }; // Apply the styles for SSR considerations\n\n    if (!renderOnlyActive) {\n      const transform = axisProperties.transform[axis](this.indexCurrent * 100);\n      containerStyle.WebkitTransform = transform;\n      containerStyle.transform = transform;\n    }\n\n    if (animateHeight) {\n      containerStyle.height = heightLatest;\n    }\n\n    return __jsx(\"div\", _extends({\n      ref: this.setRootNode,\n      style: _Object$assign({}, axisProperties.root[axis], style)\n    }, other, touchEvents, mouseEvents, {\n      onScroll: this.handleScroll,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 795\n      },\n      __self: this\n    }), __jsx(\"div\", {\n      ref: this.setContainerNode,\n      style: _Object$assign({}, containerStyle, styles.container, containerStyleProp),\n      className: \"react-swipeable-view-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 803\n      },\n      __self: this\n    }, React.Children.map(children, (child, indexChild) => {\n      if (renderOnlyActive && indexChild !== indexLatest) {\n        return null;\n      }\n\n      console.log(\"indexChild =\", indexChild);\n      warning(React.isValidElement(child), `react-swipeable-view: one of the children provided is invalid: ${child}.\nWe are expecting a valid React Element`);\n      let ref;\n      let hidden = true;\n\n      if (indexChild === indexLatest) {\n        hidden = false;\n\n        if (animateHeight) {\n          ref = this.setActiveSlide;\n          slideStyle.overflowY = 'hidden';\n        }\n      }\n\n      return __jsx(\"div\", {\n        ref: ref,\n        style: slideStyle,\n        className: slideClassName,\n        \"aria-hidden\": hidden,\n        \"data-swipeable\": \"true\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 834\n        },\n        __self: this\n      }, child);\n    })));\n  }\n\n} // Added as an ads for people using the React dev tools in production.\n// So they know, the tool used to build the awesome UI they\n// are looking at/retro engineering.\n\n\nSwipeableViews.displayName = 'ReactSwipableView';\nSwipeableViews.propTypes = {\n  /**\n   * This is callback property. It's called by the component on mount.\n   * This is useful when you want to trigger an action programmatically.\n   * It currently only supports updateHeight() action.\n   *\n   * @param {object} actions This object contains all posible actions\n   * that can be triggered programmatically.\n   */\n  action: PropTypes.func,\n\n  /**\n   * If `true`, the height of the container will be animated to match the current slide height.\n   * Animating another style property has a negative impact regarding performance.\n   */\n  animateHeight: PropTypes.bool,\n\n  /**\n   * If `false`, changes to the index prop will not cause an animated transition.\n   */\n  animateTransitions: PropTypes.bool,\n\n  /**\n   * The axis on which the slides will slide.\n   */\n  axis: PropTypes.oneOf(['x', 'x-reverse', 'y', 'y-reverse']),\n\n  /**\n   * Use this property to provide your slides.\n   */\n  children: PropTypes.node.isRequired,\n\n  /**\n   * This is the inlined style that will be applied\n   * to each slide container.\n   */\n  containerStyle: PropTypes.object,\n\n  /**\n   * If `true`, it will disable touch events.\n   * This is useful when you want to prohibit the user from changing slides.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * This is the config used to disable lazyloding,\n   * if `true` will render all the views in first rendering.\n   */\n  disableLazyLoading: PropTypes.bool,\n\n  /**\n   * If `true`, it will enable mouse events.\n   * This will allow the user to perform the relevant swipe actions with a mouse.\n   */\n  enableMouseEvents: PropTypes.bool,\n\n  /**\n   * Configure hysteresis between slides. This value determines how far\n   * should user swipe to switch slide.\n   */\n  hysteresis: PropTypes.number,\n\n  /**\n   * If `true`, it will ignore native scroll container.\n   * It can be used to filter out false positive that blocks the swipe.\n   */\n  ignoreNativeScroll: PropTypes.bool,\n\n  /**\n   * This is the index of the slide to show.\n   * This is useful when you want to change the default slide shown.\n   * Or when you have tabs linked to each slide.\n   */\n  index: PropTypes.number,\n\n  /**\n   * This is callback prop. It's call by the\n   * component when the shown slide change after a swipe made by the user.\n   * This is useful when you have tabs linked to each slide.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {integer} indexLatest This is the oldest index of the slide.\n   * @param {object} meta Meta data containing more information about the event.\n   */\n  onChangeIndex: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onMouseDown: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onMouseLeave: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onMouseMove: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onMouseUp: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onScroll: PropTypes.func,\n\n  /**\n   * This is callback prop. It's called by the\n   * component when the slide switching.\n   * This is useful when you want to implement something corresponding\n   * to the current slide position.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {string} type Can be either `move` or `end`.\n   */\n  onSwitching: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onTouchEnd: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onTouchMove: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onTouchStart: PropTypes.func,\n\n  /**\n   * The callback that fires when the animation comes to a rest.\n   * This is useful to defer CPU intensive task.\n   */\n  onTransitionEnd: PropTypes.func,\n\n  /**\n   * If `true`, it will add bounds effect on the edges.\n   */\n  resistance: PropTypes.bool,\n\n  /**\n   * This is the className that will be applied\n   * on the slide component.\n   */\n  slideClassName: PropTypes.string,\n\n  /**\n   * This is the inlined style that will be applied\n   * on the slide component.\n   */\n  slideStyle: PropTypes.object,\n\n  /**\n   * This is the config used to create CSS transitions.\n   * This is useful to change the dynamic of the transition.\n   */\n  springConfig: PropTypes.shape({\n    delay: PropTypes.string,\n    duration: PropTypes.string,\n    easeFunction: PropTypes.string\n  }),\n\n  /**\n   * This is the inlined style that will be applied\n   * on the root component.\n   */\n  style: PropTypes.object,\n\n  /**\n   * This is the threshold used for detecting a quick swipe.\n   * If the computed speed is above this value, the index change.\n   */\n  threshold: PropTypes.number\n};\nSwipeableViews.defaultProps = {\n  animateHeight: false,\n  animateTransitions: true,\n  axis: 'x',\n  disabled: false,\n  disableLazyLoading: false,\n  enableMouseEvents: false,\n  hysteresis: 0.6,\n  ignoreNativeScroll: false,\n  index: 0,\n  threshold: 5,\n  springConfig: {\n    duration: '0.35s',\n    easeFunction: 'cubic-bezier(0.15, 0.3, 0.25, 1)',\n    delay: '0s'\n  },\n  resistance: false\n};\nSwipeableViews.childContextTypes = {\n  swipeableViews: PropTypes.shape({\n    slideUpdateHeight: PropTypes.func\n  })\n};\nexport default SwipeableViews;","map":{"version":3,"sources":["/home/vagrant/webstudy/swipe/swipeable-view/pages/SwipeableViews.js"],"names":["React","PropTypes","warning","transitionInfo","addEventListener","removeEventListener","constant","checkIndexBounds","computeIndex","getDisplaySameSlide","addEventListenerEnhanced","node","event","handler","options","remove","styles","container","direction","display","willChange","slide","width","WebkitFlexShrink","flexShrink","overflow","axisProperties","root","x","overflowX","y","overflowY","flexDirection","transform","translate","length","rotationMatrix","scrollPosition","scrollLength","clientLength","createTransition","property","duration","easeFunction","delay","applyRotationMatrix","touch","axis","pageX","pageY","adaptMouse","touches","getDomTreeShapes","element","rootNode","domTreeShapes","hasAttribute","style","window","getComputedStyle","getPropertyValue","clientWidth","scrollWidth","clientHeight","scrollHeight","push","scrollLeft","scrollTop","parentNode","nodeWhoClaimedTheScroll","findNativeHandler","params","startX","some","shape","goingForward","areNotAtStart","areNotAtEnd","SwipeableViews","Component","constructor","props","undefined","containerNode","activeSlide","updateHeight","viewLength","getBoundingClientRect","lastX","vx","startY","isSwiping","started","computedStyle","transformValues","split","rootStyle","tranformNormalized","startIndex","paddingLeft","paddingRight","handleTouchStart","console","log","children","ignoreNativeScroll","onSwitching","resistance","dx","Math","abs","dy","UNCERTAINTY_THRESHOLD","indexCurrent","Children","count","preventDefault","index","target","hasFoundNativeHandler","setIndexCurrent","callback","state","displaySameSlide","isDragging","setState","indexLatest","delta","indexNew","threshold","floor","ceil","hysteresis","indexMax","onChangeIndex","reason","handleTransitionEnd","onTouchStart","handleSwipeStart","onTouchEnd","handleSwipeEnd","onMouseDown","persist","onMouseUp","onMouseLeave","onMouseMove","handleSwipeMove","onScroll","ignoreNextScrollEvents","child","offsetHeight","heightLatest","process","env","NODE_ENV","renderOnlyActive","disableLazyLoading","getChildContext","swipeableViews","slideUpdateHeight","componentDidMount","transitionListener","end","touchMoveListener","disabled","passive","firstRenderTimeout","setTimeout","action","componentWillReceiveProps","nextProps","componentWillUnmount","clearTimeout","animateTransitions","WebkitTransform","onTransitionEnd","render","animateHeight","containerStyle","containerStyleProp","enableMouseEvents","slideStyle","slideStyleProp","slideClassName","springConfig","other","touchEvents","handleTouchEnd","mouseEvents","handleMouseDown","handleMouseUp","handleMouseLeave","handleMouseMove","height","transition","WebkitTransition","additionalTranstion","WebkitFlexDirection","setRootNode","handleScroll","setContainerNode","map","indexChild","isValidElement","ref","hidden","setActiveSlide","displayName","propTypes","func","bool","oneOf","isRequired","object","number","onTouchMove","string","defaultProps","childContextTypes"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport transitionInfo from 'dom-helpers/transition/properties';\nimport addEventListener from 'dom-helpers/events/on';\nimport removeEventListener from 'dom-helpers/events/off';\nimport {\n  constant,\n  checkIndexBounds,\n  computeIndex,\n  getDisplaySameSlide,\n} from 'react-swipeable-views-core';\n\nfunction addEventListenerEnhanced(node, event, handler, options) {\n  addEventListener(node, event, handler, options);\n  return {\n    remove() {\n      removeEventListener(node, event, handler, options);\n    },\n  };\n}\n\nconst styles = {\n  container: {\n    direction: 'ltr',\n    display: 'flex',\n    willChange: 'transform',\n  },\n  slide: {\n    width: '100%',\n    WebkitFlexShrink: 0,\n    flexShrink: 0,\n    overflow: 'auto',\n  },\n};\n\nconst axisProperties = {\n  root: {\n    x: {\n      overflowX: 'hidden',\n    },\n    'x-reverse': {\n      overflowX: 'hidden',\n    },\n    y: {\n      overflowY: 'hidden',\n    },\n    'y-reverse': {\n      overflowY: 'hidden',\n    },\n  },\n  flexDirection: {\n    x: 'row',\n    'x-reverse': 'row-reverse',\n    y: 'column',\n    'y-reverse': 'column-reverse',\n  },\n  transform: {\n    x: translate => `translate(${-translate}%, 0)`,\n    'x-reverse': translate => `translate(${translate}%, 0)`,\n    y: translate => `translate(0, ${-translate}%)`,\n    'y-reverse': translate => `translate(0, ${translate}%)`,\n  },\n  length: {\n    x: 'width',\n    'x-reverse': 'width',\n    y: 'height',\n    'y-reverse': 'height',\n  },\n  rotationMatrix: {\n    x: {\n      x: [1, 0],\n      y: [0, 1],\n    },\n    'x-reverse': {\n      x: [-1, 0],\n      y: [0, 1],\n    },\n    y: {\n      x: [0, 1],\n      y: [1, 0],\n    },\n    'y-reverse': {\n      x: [0, -1],\n      y: [1, 0],\n    },\n  },\n  scrollPosition: {\n    x: 'scrollLeft',\n    'x-reverse': 'scrollLeft',\n    y: 'scrollTop',\n    'y-reverse': 'scrollTop',\n  },\n  scrollLength: {\n    x: 'scrollWidth',\n    'x-reverse': 'scrollWidth',\n    y: 'scrollHeight',\n    'y-reverse': 'scrollHeight',\n  },\n  clientLength: {\n    x: 'clientWidth',\n    'x-reverse': 'clientWidth',\n    y: 'clientHeight',\n    'y-reverse': 'clientHeight',\n  },\n};\n\nfunction createTransition(property, options) {\n  const { duration, easeFunction, delay } = options;\n\n  return `${property} ${duration} ${easeFunction} ${delay}`;\n}\n\n// We are using a 2x2 rotation matrix.\nfunction applyRotationMatrix(touch, axis) {\n  const rotationMatrix = axisProperties.rotationMatrix[axis];\n\n  return {\n    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\n    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY,\n  };\n}\n\nfunction adaptMouse(event) {\n  event.touches = [{ pageX: event.pageX, pageY: event.pageY }];\n  return event;\n}\n\nexport function getDomTreeShapes(element, rootNode) {\n  let domTreeShapes = [];\n\n  while (element && element !== rootNode) {\n    // We reach a Swipeable View, no need to look higher in the dom tree.\n    if (element.hasAttribute('data-swipeable')) {\n      break;\n    }\n\n    const style = window.getComputedStyle(element);\n\n    if (\n      // Ignore the scroll children if the element is absolute positioned.\n      style.getPropertyValue('position') === 'absolute' ||\n      // Ignore the scroll children if the element has an overflowX hidden\n      style.getPropertyValue('overflow-x') === 'hidden'\n    ) {\n      domTreeShapes = [];\n    } else if (\n      (element.clientWidth > 0 && element.scrollWidth > element.clientWidth) ||\n      (element.clientHeight > 0 && element.scrollHeight > element.clientHeight)\n    ) {\n      // Ignore the nodes that have no width.\n      // Keep elements with a scroll\n      domTreeShapes.push({\n        element,\n        scrollWidth: element.scrollWidth,\n        scrollHeight: element.scrollHeight,\n        clientWidth: element.clientWidth,\n        clientHeight: element.clientHeight,\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop,\n      });\n    }\n\n    element = element.parentNode;\n  }\n\n  return domTreeShapes;\n}\n\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\nlet nodeWhoClaimedTheScroll = null;\n\nexport function findNativeHandler(params) {\n  const { domTreeShapes, pageX, startX, axis } = params;\n\n  return domTreeShapes.some(shape => {\n    // Determine if we are going backward or forward.\n    let goingForward = pageX >= startX;\n    if (axis === 'x' || axis === 'y') {\n      goingForward = !goingForward;\n    }\n\n    const scrollPosition = shape[axisProperties.scrollPosition[axis]];\n\n    const areNotAtStart = scrollPosition > 0;\n    const areNotAtEnd =\n      scrollPosition + shape[axisProperties.clientLength[axis]] <\n      shape[axisProperties.scrollLength[axis]];\n\n    if ((goingForward && areNotAtEnd) || (!goingForward && areNotAtStart)) {\n      nodeWhoClaimedTheScroll = shape.element;\n      return true;\n    }\n\n    return false;\n  });\n}\n\nclass SwipeableViews extends React.Component {\n  rootNode = null;\n\n  containerNode = null;\n\n  ignoreNextScrollEvents = false;\n\n  viewLength = 0;\n\n  startX = 0;\n\n  lastX = 0;\n\n  vx = 0;\n\n  startY = 0;\n\n  isSwiping = undefined;\n\n  started = false;\n\n  startIndex = 0;\n\n  transitionListener = null;\n\n  touchMoveListener = null;\n\n  activeSlide = null;\n\n  indexCurrent = null;\n\n  firstRenderTimeout = null;\n\n  constructor(props) {\n    super(props);\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkIndexBounds(props);\n    }\n\n    this.state = {\n      indexLatest: props.index,\n      // Set to true as soon as the component is swiping.\n      // It's the state counter part of this.isSwiping.\n      isDragging: false,\n      // Help with SSR logic and lazy loading logic.\n      renderOnlyActive: !props.disableLazyLoading,\n      heightLatest: 0,\n      // Let the render method that we are going to display the same slide than previously.\n      displaySameSlide: true,\n    };\n    this.setIndexCurrent(props.index);\n  }\n\n  getChildContext() {\n    return {\n      swipeableViews: {\n        slideUpdateHeight: () => {\n          this.updateHeight();\n        },\n      },\n    };\n  }\n\n  componentDidMount() {\n    // Subscribe to transition end events.\n    this.transitionListener = addEventListenerEnhanced(\n      this.containerNode,\n      transitionInfo.end,\n      event => {\n        if (event.target !== this.containerNode) {\n          return;\n        }\n\n        this.handleTransitionEnd();\n      },\n    );\n\n    // Block the thread to handle that event.\n    this.touchMoveListener = addEventListenerEnhanced(\n      this.rootNode,\n      'touchmove',\n      event => {\n        // Handling touch events is disabled.\n        if (this.props.disabled) {\n          return;\n        }\n        this.handleSwipeMove(event);\n      },\n      {\n        passive: false,\n      },\n    );\n\n    if (!this.props.disableLazyLoading) {\n      this.firstRenderTimeout = setTimeout(() => {\n        this.setState({\n          renderOnlyActive: false,\n        });\n      }, 0);\n    }\n\n    // Send all functions in an object if action param is set.\n    if (this.props.action) {\n      this.props.action({\n        updateHeight: this.updateHeight,\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const { index } = nextProps;\n\n    if (typeof index === 'number' && index !== this.props.index) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkIndexBounds(nextProps);\n      }\n\n      this.setIndexCurrent(index);\n      this.setState({\n        // If true, we are going to change the children. We shoudn't animate it.\n        displaySameSlide: getDisplaySameSlide(this.props, nextProps),\n        indexLatest: index,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.transitionListener.remove();\n    this.touchMoveListener.remove();\n    clearTimeout(this.firstRenderTimeout);\n  }\n\n  setIndexCurrent(indexCurrent) {\n    if (!this.props.animateTransitions && this.indexCurrent !== indexCurrent) {\n      this.handleTransitionEnd();\n    }\n\n    this.indexCurrent = indexCurrent;\n\n    if (this.containerNode) {\n      const { axis } = this.props;\n      const transform = axisProperties.transform[axis](indexCurrent * 100);\n      this.containerNode.style.WebkitTransform = transform;\n      this.containerNode.style.transform = transform;\n    }\n  }\n\n  setRootNode = node => {\n    this.rootNode = node;\n  };\n\n  setContainerNode = node => {\n    this.containerNode = node;\n  };\n\n  setActiveSlide = node => {\n    this.activeSlide = node;\n    this.updateHeight();\n  };\n\n  handleSwipeStart = event => {\n    const { axis } = this.props;\n\n    const touch = applyRotationMatrix(event.touches[0], axis);\n\n    this.viewLength = this.rootNode.getBoundingClientRect()[axisProperties.length[axis]];\n    this.startX = touch.pageX;\n    this.lastX = touch.pageX;\n    this.vx = 0;\n    this.startY = touch.pageY;\n    this.isSwiping = undefined;\n    this.started = true;\n\n    const computedStyle = window.getComputedStyle(this.containerNode);\n    const transform =\n      computedStyle.getPropertyValue('-webkit-transform') ||\n      computedStyle.getPropertyValue('transform');\n\n    if (transform && transform !== 'none') {\n      const transformValues = transform\n        .split('(')[1]\n        .split(')')[0]\n        .split(',');\n      const rootStyle = window.getComputedStyle(this.rootNode);\n\n      const tranformNormalized = applyRotationMatrix(\n        {\n          pageX: parseInt(transformValues[4], 10),\n          pageY: parseInt(transformValues[5], 10),\n        },\n        axis,\n      );\n\n      this.startIndex =\n        -tranformNormalized.pageX /\n          (this.viewLength -\n            parseInt(rootStyle.paddingLeft, 10) -\n            parseInt(rootStyle.paddingRight, 10)) || 0;\n    }\n  };\n\n  handleSwipeMove = event => {\n    // The touch start event can be cancel.\n    // Makes sure we set a starting point.\n    if (!this.started) {\n      this.handleTouchStart(event);\n      return;\n    }\n    console.log(\"handleSwipeMove\");\n\n    // We are not supposed to hanlde this touch move.\n    if (nodeWhoClaimedTheScroll !== null && nodeWhoClaimedTheScroll !== this.rootNode) {\n      return;\n    }\n\n    const { axis, children, ignoreNativeScroll, onSwitching, resistance } = this.props;\n    const touch = applyRotationMatrix(event.touches[0], axis);\n    console.log(\"touch.pageX =\", touch.pageX, \" this.startX = \", this.startX);\n\n    // We don't know yet.\n    if (this.isSwiping === undefined) {\n      const dx = Math.abs(touch.pageX - this.startX);\n      const dy = Math.abs(touch.pageY - this.startY);\n\n      const isSwiping = dx > dy && dx > constant.UNCERTAINTY_THRESHOLD;\n\n      // We let the parent handle the scroll.\n      if (\n        !resistance &&\n        (axis === 'y' || axis === 'y-reverse') &&\n        ((this.indexCurrent === 0 && this.startX < touch.pageX) ||\n          (this.indexCurrent === React.Children.count(this.props.children) - 1 &&\n            this.startX > touch.pageX))\n      ) {\n        this.isSwiping = false;\n        return;\n      }\n\n      // We are likely to be swiping, let's prevent the scroll event.\n      if (dx > dy) {\n        event.preventDefault();\n      }\n\n      if (isSwiping === true || dy > constant.UNCERTAINTY_THRESHOLD) {\n        this.isSwiping = isSwiping;\n        this.startX = touch.pageX; // Shift the starting point.\n\n        return; // Let's wait the next touch event to move something.\n      }\n    }\n\n    if (this.isSwiping !== true) {\n      return;\n    }\n\n    // We are swiping, let's prevent the scroll event.\n    event.preventDefault();\n\n    // Low Pass filter.\n    this.vx = this.vx * 0.5 + (touch.pageX - this.lastX) * 0.5;\n    this.lastX = touch.pageX;\n\n    const { index, startX } = computeIndex({\n      children,\n      resistance,\n      pageX: touch.pageX,\n      startIndex: this.startIndex,\n      startX: this.startX,\n      viewLength: this.viewLength,\n    });\n\n    // Add support for native scroll elements.\n    if (nodeWhoClaimedTheScroll === null && !ignoreNativeScroll) {\n      console.log(\"native scroll elements\");\n      const domTreeShapes = getDomTreeShapes(event.target, this.rootNode);\n      const hasFoundNativeHandler = findNativeHandler({\n        domTreeShapes,\n        startX: this.startX,\n        pageX: touch.pageX,\n        axis,\n      });\n\n      // We abort the touch move handler.\n      if (hasFoundNativeHandler) {\n        return;\n      }\n    }\n\n    // We are moving toward the edges.\n    if (startX) {\n      this.startX = startX;\n    } else if (nodeWhoClaimedTheScroll === null) {\n      nodeWhoClaimedTheScroll = this.rootNode;\n    }\n\n    this.setIndexCurrent(index);\n\n    const callback = () => {\n      if (onSwitching) {\n        onSwitching(index, 'move');\n      }\n    };\n\n    if (this.state.displaySameSlide || !this.state.isDragging) {\n      this.setState(\n        {\n          displaySameSlide: false,\n          isDragging: true,\n        },\n        callback,\n      );\n    }\n\n    callback();\n  };\n\n  handleSwipeEnd = () => {\n    nodeWhoClaimedTheScroll = null;\n\n    // The touch start event can be cancel.\n    // Makes sure that a starting point is set.\n    if (!this.started) {\n      return;\n    }\n\n    this.started = false;\n\n    if (this.isSwiping !== true) {\n      return;\n    }\n\n    const indexLatest = this.state.indexLatest;\n    const indexCurrent = this.indexCurrent;\n    const delta = indexLatest - indexCurrent;\n\n    let indexNew;\n\n    // Quick movement\n    if (Math.abs(this.vx) > this.props.threshold) {\n      if (this.vx > 0) {\n        indexNew = Math.floor(indexCurrent);\n      } else {\n        indexNew = Math.ceil(indexCurrent);\n      }\n    } else if (Math.abs(delta) > this.props.hysteresis) {\n      // Some hysteresis with indexLatest.\n      indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);\n    } else {\n      indexNew = indexLatest;\n    }\n\n    const indexMax = React.Children.count(this.props.children) - 1;\n\n    if (indexNew < 0) {\n      indexNew = 0;\n    } else if (indexNew > indexMax) {\n      indexNew = indexMax;\n    }\n\n    this.setIndexCurrent(indexNew);\n    this.setState(\n      {\n        indexLatest: indexNew,\n        isDragging: false,\n      },\n      () => {\n        if (this.props.onSwitching) {\n          this.props.onSwitching(indexNew, 'end');\n        }\n\n        if (this.props.onChangeIndex && indexNew !== indexLatest) {\n          this.props.onChangeIndex(indexNew, indexLatest, {\n            reason: 'swipe',\n          });\n        }\n\n        // Manually calling handleTransitionEnd in that case as isn't otherwise.\n        if (indexCurrent === indexLatest) {\n          this.handleTransitionEnd();\n        }\n      },\n    );\n  };\n\n  handleTouchStart = event => {\n    if (this.props.onTouchStart) {\n      this.props.onTouchStart(event);\n    }\n    this.handleSwipeStart(event);\n  };\n\n  handleTouchEnd = event => {\n    if (this.props.onTouchEnd) {\n      this.props.onTouchEnd(event);\n    }\n    this.handleSwipeEnd(event);\n  };\n\n  handleMouseDown = event => {\n    if (this.props.onMouseDown) {\n      this.props.onMouseDown(event);\n    }\n    event.persist();\n    this.handleSwipeStart(adaptMouse(event));\n  };\n\n  handleMouseUp = event => {\n    if (this.props.onMouseUp) {\n      this.props.onMouseUp(event);\n    }\n    this.handleSwipeEnd(adaptMouse(event));\n  };\n\n  handleMouseLeave = event => {\n    if (this.props.onMouseLeave) {\n      this.props.onMouseLeave(event);\n    }\n\n    // Filter out events\n    if (this.started) {\n      this.handleSwipeEnd(adaptMouse(event));\n    }\n  };\n\n  handleMouseMove = event => {\n    if (this.props.onMouseMove) {\n      this.props.onMouseMove(event);\n    }\n\n    // Filter out events\n    if (this.started) {\n      this.handleSwipeMove(adaptMouse(event));\n    }\n  };\n\n  handleScroll = event => {\n    if (this.props.onScroll) {\n      this.props.onScroll(event);\n    }\n\n    // Ignore events bubbling up.\n    if (event.target !== this.rootNode) {\n      return;\n    }\n\n    if (this.ignoreNextScrollEvents) {\n      this.ignoreNextScrollEvents = false;\n      return;\n    }\n\n    const indexLatest = this.state.indexLatest;\n    const indexNew = Math.ceil(event.target.scrollLeft / event.target.clientWidth) + indexLatest;\n\n    this.ignoreNextScrollEvents = true;\n    // Reset the scroll position.\n    event.target.scrollLeft = 0;\n\n    if (this.props.onChangeIndex && indexNew !== indexLatest) {\n      this.props.onChangeIndex(indexNew, indexLatest, {\n        reason: 'focus',\n      });\n    }\n  };\n\n  updateHeight = () => {\n    if (this.activeSlide !== null) {\n      const child = this.activeSlide.children[0];\n      if (\n        child !== undefined &&\n        child.offsetHeight !== undefined &&\n        this.state.heightLatest !== child.offsetHeight\n      ) {\n        this.setState({\n          heightLatest: child.offsetHeight,\n        });\n      }\n    }\n  };\n\n  handleTransitionEnd() {\n    if (!this.props.onTransitionEnd) {\n      return;\n    }\n\n    // Filters out when changing the children\n    if (this.state.displaySameSlide) {\n      return;\n    }\n\n    // The rest callback is triggered when swiping. It's just noise.\n    // We filter it out.\n    if (!this.state.isDragging) {\n      this.props.onTransitionEnd();\n    }\n  }\n\n  render() {\n    const {\n      action,\n      animateHeight,\n      animateTransitions,\n      axis,\n      children,\n      containerStyle: containerStyleProp,\n      disabled,\n      disableLazyLoading,\n      enableMouseEvents,\n      hysteresis,\n      ignoreNativeScroll,\n      index,\n      onChangeIndex,\n      onSwitching,\n      onTransitionEnd,\n      resistance,\n      slideStyle: slideStyleProp,\n      slideClassName,\n      springConfig,\n      style,\n      threshold,\n      ...other\n    } = this.props;\n\n    const {\n      displaySameSlide,\n      heightLatest,\n      indexLatest,\n      isDragging,\n      renderOnlyActive,\n    } = this.state;\n    const touchEvents = !disabled\n      ? {\n          onTouchStart: this.handleTouchStart,\n          onTouchEnd: this.handleTouchEnd,\n        }\n      : {};\n    const mouseEvents =\n      !disabled && enableMouseEvents\n        ? {\n            onMouseDown: this.handleMouseDown,\n            onMouseUp: this.handleMouseUp,\n            onMouseLeave: this.handleMouseLeave,\n            onMouseMove: this.handleMouseMove,\n          }\n        : {};\n\n    // There is no point to animate if we are already providing a height.\n    warning(\n      !animateHeight || !containerStyleProp || !containerStyleProp.height,\n      `react-swipeable-view: You are setting animateHeight to true but you are\nalso providing a custom height.\nThe custom height has a higher priority than the animateHeight property.\nSo animateHeight is most likely having no effect at all.`,\n    );\n\n    const slideStyle = Object.assign({}, styles.slide, slideStyleProp);\n\n    let transition;\n    let WebkitTransition;\n\n    if (isDragging || !animateTransitions || displaySameSlide) {\n      transition = 'all 0s ease 0s';\n      WebkitTransition = 'all 0s ease 0s';\n    } else {\n      transition = createTransition('transform', springConfig);\n      WebkitTransition = createTransition('-webkit-transform', springConfig);\n\n      if (heightLatest !== 0) {\n        const additionalTranstion = `, ${createTransition('height', springConfig)}`;\n        transition += additionalTranstion;\n        WebkitTransition += additionalTranstion;\n      }\n    }\n\n    const containerStyle = {\n      height: null,\n      WebkitFlexDirection: axisProperties.flexDirection[axis],\n      flexDirection: axisProperties.flexDirection[axis],\n      WebkitTransition,\n      transition,\n    };\n\n    // Apply the styles for SSR considerations\n    if (!renderOnlyActive) {\n      const transform = axisProperties.transform[axis](this.indexCurrent * 100);\n      containerStyle.WebkitTransform = transform;\n      containerStyle.transform = transform;\n    }\n\n    if (animateHeight) {\n      containerStyle.height = heightLatest;\n    }\n\n    return (\n      <div\n        ref={this.setRootNode}\n        style={Object.assign({}, axisProperties.root[axis], style)}\n        {...other}\n        {...touchEvents}\n        {...mouseEvents}\n        onScroll={this.handleScroll}\n      >\n        <div\n          ref={this.setContainerNode}\n          style={Object.assign({}, containerStyle, styles.container, containerStyleProp)}\n          className=\"react-swipeable-view-container\"\n        >\n          {React.Children.map(children, (child, indexChild) => {\n            if (renderOnlyActive && indexChild !== indexLatest) {\n              return null;\n            }\n\n            console.log(\"indexChild =\", indexChild); \n\n            warning(\n              React.isValidElement(child),\n              `react-swipeable-view: one of the children provided is invalid: ${child}.\nWe are expecting a valid React Element`,\n            );\n\n            let ref;\n            let hidden = true;\n\n            if (indexChild === indexLatest) {\n              hidden = false;\n\n              if (animateHeight) {\n                ref = this.setActiveSlide;\n                slideStyle.overflowY = 'hidden';\n              }\n            }\n\n            return (\n              <div\n                ref={ref}\n                style={slideStyle}\n                className={slideClassName}\n                aria-hidden={hidden}\n                data-swipeable=\"true\"\n              >\n                {child}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\n// Added as an ads for people using the React dev tools in production.\n// So they know, the tool used to build the awesome UI they\n// are looking at/retro engineering.\nSwipeableViews.displayName = 'ReactSwipableView';\n\nSwipeableViews.propTypes = {\n  /**\n   * This is callback property. It's called by the component on mount.\n   * This is useful when you want to trigger an action programmatically.\n   * It currently only supports updateHeight() action.\n   *\n   * @param {object} actions This object contains all posible actions\n   * that can be triggered programmatically.\n   */\n  action: PropTypes.func,\n  /**\n   * If `true`, the height of the container will be animated to match the current slide height.\n   * Animating another style property has a negative impact regarding performance.\n   */\n  animateHeight: PropTypes.bool,\n  /**\n   * If `false`, changes to the index prop will not cause an animated transition.\n   */\n  animateTransitions: PropTypes.bool,\n  /**\n   * The axis on which the slides will slide.\n   */\n  axis: PropTypes.oneOf(['x', 'x-reverse', 'y', 'y-reverse']),\n  /**\n   * Use this property to provide your slides.\n   */\n  children: PropTypes.node.isRequired,\n  /**\n   * This is the inlined style that will be applied\n   * to each slide container.\n   */\n  containerStyle: PropTypes.object,\n  /**\n   * If `true`, it will disable touch events.\n   * This is useful when you want to prohibit the user from changing slides.\n   */\n  disabled: PropTypes.bool,\n  /**\n   * This is the config used to disable lazyloding,\n   * if `true` will render all the views in first rendering.\n   */\n  disableLazyLoading: PropTypes.bool,\n  /**\n   * If `true`, it will enable mouse events.\n   * This will allow the user to perform the relevant swipe actions with a mouse.\n   */\n  enableMouseEvents: PropTypes.bool,\n  /**\n   * Configure hysteresis between slides. This value determines how far\n   * should user swipe to switch slide.\n   */\n  hysteresis: PropTypes.number,\n  /**\n   * If `true`, it will ignore native scroll container.\n   * It can be used to filter out false positive that blocks the swipe.\n   */\n  ignoreNativeScroll: PropTypes.bool,\n  /**\n   * This is the index of the slide to show.\n   * This is useful when you want to change the default slide shown.\n   * Or when you have tabs linked to each slide.\n   */\n  index: PropTypes.number,\n  /**\n   * This is callback prop. It's call by the\n   * component when the shown slide change after a swipe made by the user.\n   * This is useful when you have tabs linked to each slide.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {integer} indexLatest This is the oldest index of the slide.\n   * @param {object} meta Meta data containing more information about the event.\n   */\n  onChangeIndex: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseDown: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseLeave: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseMove: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseUp: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onScroll: PropTypes.func,\n  /**\n   * This is callback prop. It's called by the\n   * component when the slide switching.\n   * This is useful when you want to implement something corresponding\n   * to the current slide position.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {string} type Can be either `move` or `end`.\n   */\n  onSwitching: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchEnd: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchMove: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchStart: PropTypes.func,\n  /**\n   * The callback that fires when the animation comes to a rest.\n   * This is useful to defer CPU intensive task.\n   */\n  onTransitionEnd: PropTypes.func,\n  /**\n   * If `true`, it will add bounds effect on the edges.\n   */\n  resistance: PropTypes.bool,\n  /**\n   * This is the className that will be applied\n   * on the slide component.\n   */\n  slideClassName: PropTypes.string,\n  /**\n   * This is the inlined style that will be applied\n   * on the slide component.\n   */\n  slideStyle: PropTypes.object,\n  /**\n   * This is the config used to create CSS transitions.\n   * This is useful to change the dynamic of the transition.\n   */\n  springConfig: PropTypes.shape({\n    delay: PropTypes.string,\n    duration: PropTypes.string,\n    easeFunction: PropTypes.string,\n  }),\n  /**\n   * This is the inlined style that will be applied\n   * on the root component.\n   */\n  style: PropTypes.object,\n  /**\n   * This is the threshold used for detecting a quick swipe.\n   * If the computed speed is above this value, the index change.\n   */\n  threshold: PropTypes.number,\n};\n\nSwipeableViews.defaultProps = {\n  animateHeight: false,\n  animateTransitions: true,\n  axis: 'x',\n  disabled: false,\n  disableLazyLoading: false,\n  enableMouseEvents: false,\n  hysteresis: 0.6,\n  ignoreNativeScroll: false,\n  index: 0,\n  threshold: 5,\n  springConfig: {\n    duration: '0.35s',\n    easeFunction: 'cubic-bezier(0.15, 0.3, 0.25, 1)',\n    delay: '0s',\n  },\n  resistance: false,\n};\n\nSwipeableViews.childContextTypes = {\n  swipeableViews: PropTypes.shape({\n    slideUpdateHeight: PropTypes.func,\n  }),\n};\n\nexport default SwipeableViews;\n"]},"metadata":{},"sourceType":"module"}