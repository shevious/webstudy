{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _Object$assign from \"@babel/runtime-corejs2/core-js/object/assign\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport _parseInt from \"@babel/runtime-corejs2/core-js/parse-int\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/home/vagrant/webstudy/swipe/swipeable-view/pages/SwipeableViews.js\";\nvar __jsx = React.createElement;\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport transitionInfo from 'dom-helpers/transition/properties';\nimport addEventListener from 'dom-helpers/events/on';\nimport removeEventListener from 'dom-helpers/events/off';\nimport { constant, checkIndexBounds, computeIndex, getDisplaySameSlide } from 'react-swipeable-views-core';\n\nfunction addEventListenerEnhanced(node, event, handler, options) {\n  addEventListener(node, event, handler, options);\n  return {\n    remove: function remove() {\n      removeEventListener(node, event, handler, options);\n    }\n  };\n}\n\nvar styles = {\n  container: {\n    direction: 'ltr',\n    display: 'flex',\n    willChange: 'transform'\n  },\n  slide: {\n    width: '100%',\n    WebkitFlexShrink: 0,\n    flexShrink: 0,\n    overflow: 'auto'\n  }\n};\nvar axisProperties = {\n  root: {\n    x: {\n      overflowX: 'hidden'\n    },\n    'x-reverse': {\n      overflowX: 'hidden'\n    },\n    y: {\n      overflowY: 'hidden'\n    },\n    'y-reverse': {\n      overflowY: 'hidden'\n    }\n  },\n  flexDirection: {\n    x: 'row',\n    'x-reverse': 'row-reverse',\n    y: 'column',\n    'y-reverse': 'column-reverse'\n  },\n  transform: {\n    x: function x(translate) {\n      return \"translate(\".concat(-translate, \"%, 0)\");\n    },\n    'x-reverse': function xReverse(translate) {\n      return \"translate(\".concat(translate, \"%, 0)\");\n    },\n    y: function y(translate) {\n      return \"translate(0, \".concat(-translate, \"%)\");\n    },\n    'y-reverse': function yReverse(translate) {\n      return \"translate(0, \".concat(translate, \"%)\");\n    }\n  },\n  length: {\n    x: 'width',\n    'x-reverse': 'width',\n    y: 'height',\n    'y-reverse': 'height'\n  },\n  rotationMatrix: {\n    x: {\n      x: [1, 0],\n      y: [0, 1]\n    },\n    'x-reverse': {\n      x: [-1, 0],\n      y: [0, 1]\n    },\n    y: {\n      x: [0, 1],\n      y: [1, 0]\n    },\n    'y-reverse': {\n      x: [0, -1],\n      y: [1, 0]\n    }\n  },\n  scrollPosition: {\n    x: 'scrollLeft',\n    'x-reverse': 'scrollLeft',\n    y: 'scrollTop',\n    'y-reverse': 'scrollTop'\n  },\n  scrollLength: {\n    x: 'scrollWidth',\n    'x-reverse': 'scrollWidth',\n    y: 'scrollHeight',\n    'y-reverse': 'scrollHeight'\n  },\n  clientLength: {\n    x: 'clientWidth',\n    'x-reverse': 'clientWidth',\n    y: 'clientHeight',\n    'y-reverse': 'clientHeight'\n  }\n};\n\nfunction createTransition(property, options) {\n  var duration = options.duration,\n      easeFunction = options.easeFunction,\n      delay = options.delay;\n  return \"\".concat(property, \" \").concat(duration, \" \").concat(easeFunction, \" \").concat(delay);\n} // We are using a 2x2 rotation matrix.\n\n\nfunction applyRotationMatrix(touch, axis) {\n  var rotationMatrix = axisProperties.rotationMatrix[axis];\n  return {\n    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\n    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY\n  };\n}\n\nfunction adaptMouse(event) {\n  event.touches = [{\n    pageX: event.pageX,\n    pageY: event.pageY\n  }];\n  return event;\n}\n\nexport function getDomTreeShapes(element, rootNode) {\n  var domTreeShapes = [];\n\n  while (element && element !== rootNode) {\n    // We reach a Swipeable View, no need to look higher in the dom tree.\n    if (element.hasAttribute('data-swipeable')) {\n      break;\n    }\n\n    var style = window.getComputedStyle(element);\n\n    if ( // Ignore the scroll children if the element is absolute positioned.\n    style.getPropertyValue('position') === 'absolute' || // Ignore the scroll children if the element has an overflowX hidden\n    style.getPropertyValue('overflow-x') === 'hidden') {\n      domTreeShapes = [];\n    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {\n      // Ignore the nodes that have no width.\n      // Keep elements with a scroll\n      domTreeShapes.push({\n        element: element,\n        scrollWidth: element.scrollWidth,\n        scrollHeight: element.scrollHeight,\n        clientWidth: element.clientWidth,\n        clientHeight: element.clientHeight,\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      });\n    }\n\n    element = element.parentNode;\n  }\n\n  return domTreeShapes;\n} // We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nvar nodeWhoClaimedTheScroll = null;\nexport function findNativeHandler(params) {\n  var domTreeShapes = params.domTreeShapes,\n      pageX = params.pageX,\n      startX = params.startX,\n      axis = params.axis;\n  return domTreeShapes.some(function (shape) {\n    // Determine if we are going backward or forward.\n    var goingForward = pageX >= startX;\n\n    if (axis === 'x' || axis === 'y') {\n      goingForward = !goingForward;\n    }\n\n    var scrollPosition = shape[axisProperties.scrollPosition[axis]];\n    var areNotAtStart = scrollPosition > 0;\n    var areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\n\n    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {\n      nodeWhoClaimedTheScroll = shape.element;\n      return true;\n    }\n\n    return false;\n  });\n}\n\nvar SwipeableViews =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(SwipeableViews, _React$Component);\n\n  function SwipeableViews(props) {\n    var _this;\n\n    _classCallCheck(this, SwipeableViews);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SwipeableViews).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"rootNode\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"containerNode\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"ignoreNextScrollEvents\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"viewLength\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"startX\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"lastX\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"vx\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"startY\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"isSwiping\", undefined);\n\n    _defineProperty(_assertThisInitialized(_this), \"started\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"startIndex\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"transitionListener\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"touchMoveListener\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"activeSlide\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"indexCurrent\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"firstRenderTimeout\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"setRootNode\", function (node) {\n      _this.rootNode = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setContainerNode\", function (node) {\n      _this.containerNode = node;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setActiveSlide\", function (node) {\n      _this.activeSlide = node;\n\n      _this.updateHeight();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleSwipeStart\", function (event) {\n      var axis = _this.props.axis;\n      var touch = applyRotationMatrix(event.touches[0], axis);\n      _this.viewLength = _this.rootNode.getBoundingClientRect()[axisProperties.length[axis]];\n      _this.startX = touch.pageX;\n      _this.lastX = touch.pageX;\n      _this.vx = 0;\n      _this.startY = touch.pageY;\n      _this.isSwiping = undefined;\n      _this.started = true;\n      var computedStyle = window.getComputedStyle(_this.containerNode);\n      var transform = computedStyle.getPropertyValue('-webkit-transform') || computedStyle.getPropertyValue('transform');\n\n      if (transform && transform !== 'none') {\n        var transformValues = transform.split('(')[1].split(')')[0].split(',');\n        var rootStyle = window.getComputedStyle(_this.rootNode);\n        var tranformNormalized = applyRotationMatrix({\n          pageX: _parseInt(transformValues[4], 10),\n          pageY: _parseInt(transformValues[5], 10)\n        }, axis);\n        _this.startIndex = -tranformNormalized.pageX / (_this.viewLength - _parseInt(rootStyle.paddingLeft, 10) - _parseInt(rootStyle.paddingRight, 10)) || 0;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleSwipeMove\", function (event) {\n      // The touch start event can be cancel.\n      // Makes sure we set a starting point.\n      if (!_this.started) {\n        _this.handleTouchStart(event);\n\n        return;\n      }\n\n      console.log(\"handleSwipeMove\"); // We are not supposed to hanlde this touch move.\n\n      if (nodeWhoClaimedTheScroll !== null && nodeWhoClaimedTheScroll !== _this.rootNode) {\n        return;\n      }\n\n      var _this$props = _this.props,\n          axis = _this$props.axis,\n          children = _this$props.children,\n          ignoreNativeScroll = _this$props.ignoreNativeScroll,\n          onSwitching = _this$props.onSwitching,\n          resistance = _this$props.resistance;\n      var touch = applyRotationMatrix(event.touches[0], axis);\n      console.log(\"touch.pageX =\", touch.pageX, \" this.startX = \", _this.startX); // We don't know yet.\n\n      if (_this.isSwiping === undefined) {\n        var dx = Math.abs(touch.pageX - _this.startX);\n        var dy = Math.abs(touch.pageY - _this.startY);\n        var isSwiping = dx > dy && dx > constant.UNCERTAINTY_THRESHOLD; // We let the parent handle the scroll.\n\n        if (!resistance && (axis === 'y' || axis === 'y-reverse') && (_this.indexCurrent === 0 && _this.startX < touch.pageX || _this.indexCurrent === React.Children.count(_this.props.children) - 1 && _this.startX > touch.pageX)) {\n          _this.isSwiping = false;\n          return;\n        } // We are likely to be swiping, let's prevent the scroll event.\n\n\n        if (dx > dy) {\n          event.preventDefault();\n        }\n\n        if (isSwiping === true || dy > constant.UNCERTAINTY_THRESHOLD) {\n          _this.isSwiping = isSwiping;\n          _this.startX = touch.pageX; // Shift the starting point.\n\n          return; // Let's wait the next touch event to move something.\n        }\n      }\n\n      if (_this.isSwiping !== true) {\n        return;\n      } // We are swiping, let's prevent the scroll event.\n\n\n      event.preventDefault(); // Low Pass filter.\n\n      _this.vx = _this.vx * 0.5 + (touch.pageX - _this.lastX) * 0.5;\n      _this.lastX = touch.pageX;\n\n      var _computeIndex = computeIndex({\n        children: children,\n        resistance: resistance,\n        pageX: touch.pageX,\n        startIndex: _this.startIndex,\n        startX: _this.startX,\n        viewLength: _this.viewLength\n      }),\n          index = _computeIndex.index,\n          startX = _computeIndex.startX; // Add support for native scroll elements.\n\n\n      if (nodeWhoClaimedTheScroll === null && !ignoreNativeScroll) {\n        console.log(\"native scroll elements\");\n        var domTreeShapes = getDomTreeShapes(event.target, _this.rootNode);\n        var hasFoundNativeHandler = findNativeHandler({\n          domTreeShapes: domTreeShapes,\n          startX: _this.startX,\n          pageX: touch.pageX,\n          axis: axis\n        }); // We abort the touch move handler.\n\n        if (hasFoundNativeHandler) {\n          return;\n        }\n      } // We are moving toward the edges.\n\n\n      if (startX) {\n        _this.startX = startX;\n      } else if (nodeWhoClaimedTheScroll === null) {\n        nodeWhoClaimedTheScroll = _this.rootNode;\n      }\n\n      _this.setIndexCurrent(index);\n\n      var callback = function callback() {\n        if (onSwitching) {\n          onSwitching(index, 'move');\n        }\n      };\n\n      if (_this.state.displaySameSlide || !_this.state.isDragging) {\n        _this.setState({\n          displaySameSlide: false,\n          isDragging: true\n        }, callback);\n      }\n\n      callback();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleSwipeEnd\", function () {\n      nodeWhoClaimedTheScroll = null; // The touch start event can be cancel.\n      // Makes sure that a starting point is set.\n\n      if (!_this.started) {\n        return;\n      }\n\n      _this.started = false;\n\n      if (_this.isSwiping !== true) {\n        return;\n      }\n\n      var indexLatest = _this.state.indexLatest;\n      var indexCurrent = _this.indexCurrent;\n      var delta = indexLatest - indexCurrent;\n      var indexNew; // Quick movement\n\n      if (Math.abs(_this.vx) > _this.props.threshold) {\n        if (_this.vx > 0) {\n          indexNew = Math.floor(indexCurrent);\n        } else {\n          indexNew = Math.ceil(indexCurrent);\n        }\n      } else if (Math.abs(delta) > _this.props.hysteresis) {\n        // Some hysteresis with indexLatest.\n        indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);\n      } else {\n        indexNew = indexLatest;\n      }\n\n      var indexMax = React.Children.count(_this.props.children) - 1;\n\n      if (indexNew < 0) {\n        indexNew = 0;\n      } else if (indexNew > indexMax) {\n        indexNew = indexMax;\n      }\n\n      _this.setIndexCurrent(indexNew);\n\n      _this.setState({\n        indexLatest: indexNew,\n        isDragging: false\n      }, function () {\n        if (_this.props.onSwitching) {\n          _this.props.onSwitching(indexNew, 'end');\n        }\n\n        if (_this.props.onChangeIndex && indexNew !== indexLatest) {\n          _this.props.onChangeIndex(indexNew, indexLatest, {\n            reason: 'swipe'\n          });\n        } // Manually calling handleTransitionEnd in that case as isn't otherwise.\n\n\n        if (indexCurrent === indexLatest) {\n          _this.handleTransitionEnd();\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleTouchStart\", function (event) {\n      if (_this.props.onTouchStart) {\n        _this.props.onTouchStart(event);\n      }\n\n      _this.handleSwipeStart(event);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleTouchEnd\", function (event) {\n      if (_this.props.onTouchEnd) {\n        _this.props.onTouchEnd(event);\n      }\n\n      _this.handleSwipeEnd(event);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleMouseDown\", function (event) {\n      if (_this.props.onMouseDown) {\n        _this.props.onMouseDown(event);\n      }\n\n      event.persist();\n\n      _this.handleSwipeStart(adaptMouse(event));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleMouseUp\", function (event) {\n      if (_this.props.onMouseUp) {\n        _this.props.onMouseUp(event);\n      }\n\n      _this.handleSwipeEnd(adaptMouse(event));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleMouseLeave\", function (event) {\n      if (_this.props.onMouseLeave) {\n        _this.props.onMouseLeave(event);\n      } // Filter out events\n\n\n      if (_this.started) {\n        _this.handleSwipeEnd(adaptMouse(event));\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleMouseMove\", function (event) {\n      if (_this.props.onMouseMove) {\n        _this.props.onMouseMove(event);\n      } // Filter out events\n\n\n      if (_this.started) {\n        _this.handleSwipeMove(adaptMouse(event));\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handleScroll\", function (event) {\n      if (_this.props.onScroll) {\n        _this.props.onScroll(event);\n      } // Ignore events bubbling up.\n\n\n      if (event.target !== _this.rootNode) {\n        return;\n      }\n\n      if (_this.ignoreNextScrollEvents) {\n        _this.ignoreNextScrollEvents = false;\n        return;\n      }\n\n      var indexLatest = _this.state.indexLatest;\n      var indexNew = Math.ceil(event.target.scrollLeft / event.target.clientWidth) + indexLatest;\n      _this.ignoreNextScrollEvents = true; // Reset the scroll position.\n\n      event.target.scrollLeft = 0;\n\n      if (_this.props.onChangeIndex && indexNew !== indexLatest) {\n        _this.props.onChangeIndex(indexNew, indexLatest, {\n          reason: 'focus'\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateHeight\", function () {\n      if (_this.activeSlide !== null) {\n        var child = _this.activeSlide.children[0];\n\n        if (child !== undefined && child.offsetHeight !== undefined && _this.state.heightLatest !== child.offsetHeight) {\n          _this.setState({\n            heightLatest: child.offsetHeight\n          });\n        }\n      }\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkIndexBounds(props);\n    }\n\n    _this.state = {\n      indexLatest: props.index,\n      // Set to true as soon as the component is swiping.\n      // It's the state counter part of this.isSwiping.\n      isDragging: false,\n      // Help with SSR logic and lazy loading logic.\n      renderOnlyActive: !props.disableLazyLoading,\n      heightLatest: 0,\n      // Let the render method that we are going to display the same slide than previously.\n      displaySameSlide: true\n    };\n\n    _this.setIndexCurrent(props.index);\n\n    return _this;\n  }\n\n  _createClass(SwipeableViews, [{\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      var _this2 = this;\n\n      return {\n        swipeableViews: {\n          slideUpdateHeight: function slideUpdateHeight() {\n            _this2.updateHeight();\n          }\n        }\n      };\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this3 = this;\n\n      // Subscribe to transition end events.\n      this.transitionListener = addEventListenerEnhanced(this.containerNode, transitionInfo.end, function (event) {\n        if (event.target !== _this3.containerNode) {\n          return;\n        }\n\n        _this3.handleTransitionEnd();\n      }); // Block the thread to handle that event.\n\n      this.touchMoveListener = addEventListenerEnhanced(this.rootNode, 'touchmove', function (event) {\n        // Handling touch events is disabled.\n        if (_this3.props.disabled) {\n          return;\n        }\n\n        _this3.handleSwipeMove(event);\n      }, {\n        passive: false\n      });\n\n      if (!this.props.disableLazyLoading) {\n        this.firstRenderTimeout = setTimeout(function () {\n          _this3.setState({\n            renderOnlyActive: false\n          });\n        }, 0);\n      } // Send all functions in an object if action param is set.\n\n\n      if (this.props.action) {\n        this.props.action({\n          updateHeight: this.updateHeight\n        });\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var index = nextProps.index;\n\n      if (typeof index === 'number' && index !== this.props.index) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkIndexBounds(nextProps);\n        }\n\n        this.setIndexCurrent(index);\n        this.setState({\n          // If true, we are going to change the children. We shoudn't animate it.\n          displaySameSlide: getDisplaySameSlide(this.props, nextProps),\n          indexLatest: index\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.transitionListener.remove();\n      this.touchMoveListener.remove();\n      clearTimeout(this.firstRenderTimeout);\n    }\n  }, {\n    key: \"setIndexCurrent\",\n    value: function setIndexCurrent(indexCurrent) {\n      if (!this.props.animateTransitions && this.indexCurrent !== indexCurrent) {\n        this.handleTransitionEnd();\n      }\n\n      this.indexCurrent = indexCurrent;\n\n      if (this.containerNode) {\n        var axis = this.props.axis;\n        var transform = axisProperties.transform[axis](indexCurrent * 100);\n        this.containerNode.style.WebkitTransform = transform;\n        this.containerNode.style.transform = transform;\n      }\n    }\n  }, {\n    key: \"handleTransitionEnd\",\n    value: function handleTransitionEnd() {\n      if (!this.props.onTransitionEnd) {\n        return;\n      } // Filters out when changing the children\n\n\n      if (this.state.displaySameSlide) {\n        return;\n      } // The rest callback is triggered when swiping. It's just noise.\n      // We filter it out.\n\n\n      if (!this.state.isDragging) {\n        this.props.onTransitionEnd();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$props2 = this.props,\n          action = _this$props2.action,\n          animateHeight = _this$props2.animateHeight,\n          animateTransitions = _this$props2.animateTransitions,\n          axis = _this$props2.axis,\n          children = _this$props2.children,\n          containerStyleProp = _this$props2.containerStyle,\n          disabled = _this$props2.disabled,\n          disableLazyLoading = _this$props2.disableLazyLoading,\n          enableMouseEvents = _this$props2.enableMouseEvents,\n          hysteresis = _this$props2.hysteresis,\n          ignoreNativeScroll = _this$props2.ignoreNativeScroll,\n          index = _this$props2.index,\n          onChangeIndex = _this$props2.onChangeIndex,\n          onSwitching = _this$props2.onSwitching,\n          onTransitionEnd = _this$props2.onTransitionEnd,\n          resistance = _this$props2.resistance,\n          slideStyleProp = _this$props2.slideStyle,\n          slideClassName = _this$props2.slideClassName,\n          springConfig = _this$props2.springConfig,\n          style = _this$props2.style,\n          threshold = _this$props2.threshold,\n          other = _objectWithoutProperties(_this$props2, [\"action\", \"animateHeight\", \"animateTransitions\", \"axis\", \"children\", \"containerStyle\", \"disabled\", \"disableLazyLoading\", \"enableMouseEvents\", \"hysteresis\", \"ignoreNativeScroll\", \"index\", \"onChangeIndex\", \"onSwitching\", \"onTransitionEnd\", \"resistance\", \"slideStyle\", \"slideClassName\", \"springConfig\", \"style\", \"threshold\"]);\n\n      var _this$state = this.state,\n          displaySameSlide = _this$state.displaySameSlide,\n          heightLatest = _this$state.heightLatest,\n          indexLatest = _this$state.indexLatest,\n          isDragging = _this$state.isDragging,\n          renderOnlyActive = _this$state.renderOnlyActive;\n      var touchEvents = !disabled ? {\n        onTouchStart: this.handleTouchStart,\n        onTouchEnd: this.handleTouchEnd\n      } : {};\n      var mouseEvents = !disabled && enableMouseEvents ? {\n        onMouseDown: this.handleMouseDown,\n        onMouseUp: this.handleMouseUp,\n        onMouseLeave: this.handleMouseLeave,\n        onMouseMove: this.handleMouseMove\n      } : {}; // There is no point to animate if we are already providing a height.\n\n      warning(!animateHeight || !containerStyleProp || !containerStyleProp.height, \"react-swipeable-view: You are setting animateHeight to true but you are\\nalso providing a custom height.\\nThe custom height has a higher priority than the animateHeight property.\\nSo animateHeight is most likely having no effect at all.\");\n\n      var slideStyle = _Object$assign({}, styles.slide, slideStyleProp);\n\n      var transition;\n      var WebkitTransition;\n\n      if (isDragging || !animateTransitions || displaySameSlide) {\n        transition = 'all 0s ease 0s';\n        WebkitTransition = 'all 0s ease 0s';\n      } else {\n        transition = createTransition('transform', springConfig);\n        WebkitTransition = createTransition('-webkit-transform', springConfig);\n\n        if (heightLatest !== 0) {\n          var additionalTranstion = \", \".concat(createTransition('height', springConfig));\n          transition += additionalTranstion;\n          WebkitTransition += additionalTranstion;\n        }\n      }\n\n      var containerStyle = {\n        height: null,\n        WebkitFlexDirection: axisProperties.flexDirection[axis],\n        flexDirection: axisProperties.flexDirection[axis],\n        WebkitTransition: WebkitTransition,\n        transition: transition\n      }; // Apply the styles for SSR considerations\n\n      if (!renderOnlyActive) {\n        var transform = axisProperties.transform[axis](this.indexCurrent * 100);\n        containerStyle.WebkitTransform = transform;\n        containerStyle.transform = transform;\n      }\n\n      if (animateHeight) {\n        containerStyle.height = heightLatest;\n      }\n\n      return __jsx(\"div\", _extends({\n        ref: this.setRootNode,\n        style: _Object$assign({}, axisProperties.root[axis], style)\n      }, other, touchEvents, mouseEvents, {\n        onScroll: this.handleScroll,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 795\n        },\n        __self: this\n      }), __jsx(\"div\", {\n        ref: this.setContainerNode,\n        style: _Object$assign({}, containerStyle, styles.container, containerStyleProp),\n        className: \"react-swipeable-view-container\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 803\n        },\n        __self: this\n      }, React.Children.map(children, function (child, indexChild) {\n        if (renderOnlyActive && indexChild !== indexLatest) {\n          return null;\n        }\n\n        console.log(\"indexChild =\", indexChild);\n        warning(React.isValidElement(child), \"react-swipeable-view: one of the children provided is invalid: \".concat(child, \".\\nWe are expecting a valid React Element\"));\n        var ref;\n        var hidden = true;\n\n        if (indexChild === indexLatest) {\n          hidden = false;\n\n          if (animateHeight) {\n            ref = _this4.setActiveSlide;\n            slideStyle.overflowY = 'hidden';\n          }\n        }\n\n        return __jsx(\"div\", {\n          ref: ref,\n          style: slideStyle,\n          className: slideClassName,\n          \"aria-hidden\": hidden,\n          \"data-swipeable\": \"true\",\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 834\n          },\n          __self: this\n        }, child);\n      })));\n    }\n  }]);\n\n  return SwipeableViews;\n}(React.Component); // Added as an ads for people using the React dev tools in production.\n// So they know, the tool used to build the awesome UI they\n// are looking at/retro engineering.\n\n\nSwipeableViews.displayName = 'ReactSwipableView';\nSwipeableViews.propTypes = {\n  /**\n   * This is callback property. It's called by the component on mount.\n   * This is useful when you want to trigger an action programmatically.\n   * It currently only supports updateHeight() action.\n   *\n   * @param {object} actions This object contains all posible actions\n   * that can be triggered programmatically.\n   */\n  action: PropTypes.func,\n\n  /**\n   * If `true`, the height of the container will be animated to match the current slide height.\n   * Animating another style property has a negative impact regarding performance.\n   */\n  animateHeight: PropTypes.bool,\n\n  /**\n   * If `false`, changes to the index prop will not cause an animated transition.\n   */\n  animateTransitions: PropTypes.bool,\n\n  /**\n   * The axis on which the slides will slide.\n   */\n  axis: PropTypes.oneOf(['x', 'x-reverse', 'y', 'y-reverse']),\n\n  /**\n   * Use this property to provide your slides.\n   */\n  children: PropTypes.node.isRequired,\n\n  /**\n   * This is the inlined style that will be applied\n   * to each slide container.\n   */\n  containerStyle: PropTypes.object,\n\n  /**\n   * If `true`, it will disable touch events.\n   * This is useful when you want to prohibit the user from changing slides.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * This is the config used to disable lazyloding,\n   * if `true` will render all the views in first rendering.\n   */\n  disableLazyLoading: PropTypes.bool,\n\n  /**\n   * If `true`, it will enable mouse events.\n   * This will allow the user to perform the relevant swipe actions with a mouse.\n   */\n  enableMouseEvents: PropTypes.bool,\n\n  /**\n   * Configure hysteresis between slides. This value determines how far\n   * should user swipe to switch slide.\n   */\n  hysteresis: PropTypes.number,\n\n  /**\n   * If `true`, it will ignore native scroll container.\n   * It can be used to filter out false positive that blocks the swipe.\n   */\n  ignoreNativeScroll: PropTypes.bool,\n\n  /**\n   * This is the index of the slide to show.\n   * This is useful when you want to change the default slide shown.\n   * Or when you have tabs linked to each slide.\n   */\n  index: PropTypes.number,\n\n  /**\n   * This is callback prop. It's call by the\n   * component when the shown slide change after a swipe made by the user.\n   * This is useful when you have tabs linked to each slide.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {integer} indexLatest This is the oldest index of the slide.\n   * @param {object} meta Meta data containing more information about the event.\n   */\n  onChangeIndex: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onMouseDown: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onMouseLeave: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onMouseMove: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onMouseUp: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onScroll: PropTypes.func,\n\n  /**\n   * This is callback prop. It's called by the\n   * component when the slide switching.\n   * This is useful when you want to implement something corresponding\n   * to the current slide position.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {string} type Can be either `move` or `end`.\n   */\n  onSwitching: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onTouchEnd: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onTouchMove: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onTouchStart: PropTypes.func,\n\n  /**\n   * The callback that fires when the animation comes to a rest.\n   * This is useful to defer CPU intensive task.\n   */\n  onTransitionEnd: PropTypes.func,\n\n  /**\n   * If `true`, it will add bounds effect on the edges.\n   */\n  resistance: PropTypes.bool,\n\n  /**\n   * This is the className that will be applied\n   * on the slide component.\n   */\n  slideClassName: PropTypes.string,\n\n  /**\n   * This is the inlined style that will be applied\n   * on the slide component.\n   */\n  slideStyle: PropTypes.object,\n\n  /**\n   * This is the config used to create CSS transitions.\n   * This is useful to change the dynamic of the transition.\n   */\n  springConfig: PropTypes.shape({\n    delay: PropTypes.string,\n    duration: PropTypes.string,\n    easeFunction: PropTypes.string\n  }),\n\n  /**\n   * This is the inlined style that will be applied\n   * on the root component.\n   */\n  style: PropTypes.object,\n\n  /**\n   * This is the threshold used for detecting a quick swipe.\n   * If the computed speed is above this value, the index change.\n   */\n  threshold: PropTypes.number\n};\nSwipeableViews.defaultProps = {\n  animateHeight: false,\n  animateTransitions: true,\n  axis: 'x',\n  disabled: false,\n  disableLazyLoading: false,\n  enableMouseEvents: false,\n  hysteresis: 0.6,\n  ignoreNativeScroll: false,\n  index: 0,\n  threshold: 5,\n  springConfig: {\n    duration: '0.35s',\n    easeFunction: 'cubic-bezier(0.15, 0.3, 0.25, 1)',\n    delay: '0s'\n  },\n  resistance: false\n};\nSwipeableViews.childContextTypes = {\n  swipeableViews: PropTypes.shape({\n    slideUpdateHeight: PropTypes.func\n  })\n};\nexport default SwipeableViews;","map":{"version":3,"sources":["/home/vagrant/webstudy/swipe/swipeable-view/pages/SwipeableViews.js"],"names":["React","PropTypes","warning","transitionInfo","addEventListener","removeEventListener","constant","checkIndexBounds","computeIndex","getDisplaySameSlide","addEventListenerEnhanced","node","event","handler","options","remove","styles","container","direction","display","willChange","slide","width","WebkitFlexShrink","flexShrink","overflow","axisProperties","root","x","overflowX","y","overflowY","flexDirection","transform","translate","length","rotationMatrix","scrollPosition","scrollLength","clientLength","createTransition","property","duration","easeFunction","delay","applyRotationMatrix","touch","axis","pageX","pageY","adaptMouse","touches","getDomTreeShapes","element","rootNode","domTreeShapes","hasAttribute","style","window","getComputedStyle","getPropertyValue","clientWidth","scrollWidth","clientHeight","scrollHeight","push","scrollLeft","scrollTop","parentNode","nodeWhoClaimedTheScroll","findNativeHandler","params","startX","some","shape","goingForward","areNotAtStart","areNotAtEnd","SwipeableViews","props","undefined","containerNode","activeSlide","updateHeight","viewLength","getBoundingClientRect","lastX","vx","startY","isSwiping","started","computedStyle","transformValues","split","rootStyle","tranformNormalized","startIndex","paddingLeft","paddingRight","handleTouchStart","console","log","children","ignoreNativeScroll","onSwitching","resistance","dx","Math","abs","dy","UNCERTAINTY_THRESHOLD","indexCurrent","Children","count","preventDefault","index","target","hasFoundNativeHandler","setIndexCurrent","callback","state","displaySameSlide","isDragging","setState","indexLatest","delta","indexNew","threshold","floor","ceil","hysteresis","indexMax","onChangeIndex","reason","handleTransitionEnd","onTouchStart","handleSwipeStart","onTouchEnd","handleSwipeEnd","onMouseDown","persist","onMouseUp","onMouseLeave","onMouseMove","handleSwipeMove","onScroll","ignoreNextScrollEvents","child","offsetHeight","heightLatest","process","env","NODE_ENV","renderOnlyActive","disableLazyLoading","swipeableViews","slideUpdateHeight","transitionListener","end","touchMoveListener","disabled","passive","firstRenderTimeout","setTimeout","action","nextProps","clearTimeout","animateTransitions","WebkitTransform","onTransitionEnd","animateHeight","containerStyleProp","containerStyle","enableMouseEvents","slideStyleProp","slideStyle","slideClassName","springConfig","other","touchEvents","handleTouchEnd","mouseEvents","handleMouseDown","handleMouseUp","handleMouseLeave","handleMouseMove","height","transition","WebkitTransition","additionalTranstion","WebkitFlexDirection","setRootNode","handleScroll","setContainerNode","map","indexChild","isValidElement","ref","hidden","setActiveSlide","Component","displayName","propTypes","func","bool","oneOf","isRequired","object","number","onTouchMove","string","defaultProps","childContextTypes"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport warning from 'warning';\nimport transitionInfo from 'dom-helpers/transition/properties';\nimport addEventListener from 'dom-helpers/events/on';\nimport removeEventListener from 'dom-helpers/events/off';\nimport {\n  constant,\n  checkIndexBounds,\n  computeIndex,\n  getDisplaySameSlide,\n} from 'react-swipeable-views-core';\n\nfunction addEventListenerEnhanced(node, event, handler, options) {\n  addEventListener(node, event, handler, options);\n  return {\n    remove() {\n      removeEventListener(node, event, handler, options);\n    },\n  };\n}\n\nconst styles = {\n  container: {\n    direction: 'ltr',\n    display: 'flex',\n    willChange: 'transform',\n  },\n  slide: {\n    width: '100%',\n    WebkitFlexShrink: 0,\n    flexShrink: 0,\n    overflow: 'auto',\n  },\n};\n\nconst axisProperties = {\n  root: {\n    x: {\n      overflowX: 'hidden',\n    },\n    'x-reverse': {\n      overflowX: 'hidden',\n    },\n    y: {\n      overflowY: 'hidden',\n    },\n    'y-reverse': {\n      overflowY: 'hidden',\n    },\n  },\n  flexDirection: {\n    x: 'row',\n    'x-reverse': 'row-reverse',\n    y: 'column',\n    'y-reverse': 'column-reverse',\n  },\n  transform: {\n    x: translate => `translate(${-translate}%, 0)`,\n    'x-reverse': translate => `translate(${translate}%, 0)`,\n    y: translate => `translate(0, ${-translate}%)`,\n    'y-reverse': translate => `translate(0, ${translate}%)`,\n  },\n  length: {\n    x: 'width',\n    'x-reverse': 'width',\n    y: 'height',\n    'y-reverse': 'height',\n  },\n  rotationMatrix: {\n    x: {\n      x: [1, 0],\n      y: [0, 1],\n    },\n    'x-reverse': {\n      x: [-1, 0],\n      y: [0, 1],\n    },\n    y: {\n      x: [0, 1],\n      y: [1, 0],\n    },\n    'y-reverse': {\n      x: [0, -1],\n      y: [1, 0],\n    },\n  },\n  scrollPosition: {\n    x: 'scrollLeft',\n    'x-reverse': 'scrollLeft',\n    y: 'scrollTop',\n    'y-reverse': 'scrollTop',\n  },\n  scrollLength: {\n    x: 'scrollWidth',\n    'x-reverse': 'scrollWidth',\n    y: 'scrollHeight',\n    'y-reverse': 'scrollHeight',\n  },\n  clientLength: {\n    x: 'clientWidth',\n    'x-reverse': 'clientWidth',\n    y: 'clientHeight',\n    'y-reverse': 'clientHeight',\n  },\n};\n\nfunction createTransition(property, options) {\n  const { duration, easeFunction, delay } = options;\n\n  return `${property} ${duration} ${easeFunction} ${delay}`;\n}\n\n// We are using a 2x2 rotation matrix.\nfunction applyRotationMatrix(touch, axis) {\n  const rotationMatrix = axisProperties.rotationMatrix[axis];\n\n  return {\n    pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\n    pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY,\n  };\n}\n\nfunction adaptMouse(event) {\n  event.touches = [{ pageX: event.pageX, pageY: event.pageY }];\n  return event;\n}\n\nexport function getDomTreeShapes(element, rootNode) {\n  let domTreeShapes = [];\n\n  while (element && element !== rootNode) {\n    // We reach a Swipeable View, no need to look higher in the dom tree.\n    if (element.hasAttribute('data-swipeable')) {\n      break;\n    }\n\n    const style = window.getComputedStyle(element);\n\n    if (\n      // Ignore the scroll children if the element is absolute positioned.\n      style.getPropertyValue('position') === 'absolute' ||\n      // Ignore the scroll children if the element has an overflowX hidden\n      style.getPropertyValue('overflow-x') === 'hidden'\n    ) {\n      domTreeShapes = [];\n    } else if (\n      (element.clientWidth > 0 && element.scrollWidth > element.clientWidth) ||\n      (element.clientHeight > 0 && element.scrollHeight > element.clientHeight)\n    ) {\n      // Ignore the nodes that have no width.\n      // Keep elements with a scroll\n      domTreeShapes.push({\n        element,\n        scrollWidth: element.scrollWidth,\n        scrollHeight: element.scrollHeight,\n        clientWidth: element.clientWidth,\n        clientHeight: element.clientHeight,\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop,\n      });\n    }\n\n    element = element.parentNode;\n  }\n\n  return domTreeShapes;\n}\n\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\nlet nodeWhoClaimedTheScroll = null;\n\nexport function findNativeHandler(params) {\n  const { domTreeShapes, pageX, startX, axis } = params;\n\n  return domTreeShapes.some(shape => {\n    // Determine if we are going backward or forward.\n    let goingForward = pageX >= startX;\n    if (axis === 'x' || axis === 'y') {\n      goingForward = !goingForward;\n    }\n\n    const scrollPosition = shape[axisProperties.scrollPosition[axis]];\n\n    const areNotAtStart = scrollPosition > 0;\n    const areNotAtEnd =\n      scrollPosition + shape[axisProperties.clientLength[axis]] <\n      shape[axisProperties.scrollLength[axis]];\n\n    if ((goingForward && areNotAtEnd) || (!goingForward && areNotAtStart)) {\n      nodeWhoClaimedTheScroll = shape.element;\n      return true;\n    }\n\n    return false;\n  });\n}\n\nclass SwipeableViews extends React.Component {\n  rootNode = null;\n\n  containerNode = null;\n\n  ignoreNextScrollEvents = false;\n\n  viewLength = 0;\n\n  startX = 0;\n\n  lastX = 0;\n\n  vx = 0;\n\n  startY = 0;\n\n  isSwiping = undefined;\n\n  started = false;\n\n  startIndex = 0;\n\n  transitionListener = null;\n\n  touchMoveListener = null;\n\n  activeSlide = null;\n\n  indexCurrent = null;\n\n  firstRenderTimeout = null;\n\n  constructor(props) {\n    super(props);\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkIndexBounds(props);\n    }\n\n    this.state = {\n      indexLatest: props.index,\n      // Set to true as soon as the component is swiping.\n      // It's the state counter part of this.isSwiping.\n      isDragging: false,\n      // Help with SSR logic and lazy loading logic.\n      renderOnlyActive: !props.disableLazyLoading,\n      heightLatest: 0,\n      // Let the render method that we are going to display the same slide than previously.\n      displaySameSlide: true,\n    };\n    this.setIndexCurrent(props.index);\n  }\n\n  getChildContext() {\n    return {\n      swipeableViews: {\n        slideUpdateHeight: () => {\n          this.updateHeight();\n        },\n      },\n    };\n  }\n\n  componentDidMount() {\n    // Subscribe to transition end events.\n    this.transitionListener = addEventListenerEnhanced(\n      this.containerNode,\n      transitionInfo.end,\n      event => {\n        if (event.target !== this.containerNode) {\n          return;\n        }\n\n        this.handleTransitionEnd();\n      },\n    );\n\n    // Block the thread to handle that event.\n    this.touchMoveListener = addEventListenerEnhanced(\n      this.rootNode,\n      'touchmove',\n      event => {\n        // Handling touch events is disabled.\n        if (this.props.disabled) {\n          return;\n        }\n        this.handleSwipeMove(event);\n      },\n      {\n        passive: false,\n      },\n    );\n\n    if (!this.props.disableLazyLoading) {\n      this.firstRenderTimeout = setTimeout(() => {\n        this.setState({\n          renderOnlyActive: false,\n        });\n      }, 0);\n    }\n\n    // Send all functions in an object if action param is set.\n    if (this.props.action) {\n      this.props.action({\n        updateHeight: this.updateHeight,\n      });\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const { index } = nextProps;\n\n    if (typeof index === 'number' && index !== this.props.index) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkIndexBounds(nextProps);\n      }\n\n      this.setIndexCurrent(index);\n      this.setState({\n        // If true, we are going to change the children. We shoudn't animate it.\n        displaySameSlide: getDisplaySameSlide(this.props, nextProps),\n        indexLatest: index,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.transitionListener.remove();\n    this.touchMoveListener.remove();\n    clearTimeout(this.firstRenderTimeout);\n  }\n\n  setIndexCurrent(indexCurrent) {\n    if (!this.props.animateTransitions && this.indexCurrent !== indexCurrent) {\n      this.handleTransitionEnd();\n    }\n\n    this.indexCurrent = indexCurrent;\n\n    if (this.containerNode) {\n      const { axis } = this.props;\n      const transform = axisProperties.transform[axis](indexCurrent * 100);\n      this.containerNode.style.WebkitTransform = transform;\n      this.containerNode.style.transform = transform;\n    }\n  }\n\n  setRootNode = node => {\n    this.rootNode = node;\n  };\n\n  setContainerNode = node => {\n    this.containerNode = node;\n  };\n\n  setActiveSlide = node => {\n    this.activeSlide = node;\n    this.updateHeight();\n  };\n\n  handleSwipeStart = event => {\n    const { axis } = this.props;\n\n    const touch = applyRotationMatrix(event.touches[0], axis);\n\n    this.viewLength = this.rootNode.getBoundingClientRect()[axisProperties.length[axis]];\n    this.startX = touch.pageX;\n    this.lastX = touch.pageX;\n    this.vx = 0;\n    this.startY = touch.pageY;\n    this.isSwiping = undefined;\n    this.started = true;\n\n    const computedStyle = window.getComputedStyle(this.containerNode);\n    const transform =\n      computedStyle.getPropertyValue('-webkit-transform') ||\n      computedStyle.getPropertyValue('transform');\n\n    if (transform && transform !== 'none') {\n      const transformValues = transform\n        .split('(')[1]\n        .split(')')[0]\n        .split(',');\n      const rootStyle = window.getComputedStyle(this.rootNode);\n\n      const tranformNormalized = applyRotationMatrix(\n        {\n          pageX: parseInt(transformValues[4], 10),\n          pageY: parseInt(transformValues[5], 10),\n        },\n        axis,\n      );\n\n      this.startIndex =\n        -tranformNormalized.pageX /\n          (this.viewLength -\n            parseInt(rootStyle.paddingLeft, 10) -\n            parseInt(rootStyle.paddingRight, 10)) || 0;\n    }\n  };\n\n  handleSwipeMove = event => {\n    // The touch start event can be cancel.\n    // Makes sure we set a starting point.\n    if (!this.started) {\n      this.handleTouchStart(event);\n      return;\n    }\n    console.log(\"handleSwipeMove\");\n\n    // We are not supposed to hanlde this touch move.\n    if (nodeWhoClaimedTheScroll !== null && nodeWhoClaimedTheScroll !== this.rootNode) {\n      return;\n    }\n\n    const { axis, children, ignoreNativeScroll, onSwitching, resistance } = this.props;\n    const touch = applyRotationMatrix(event.touches[0], axis);\n    console.log(\"touch.pageX =\", touch.pageX, \" this.startX = \", this.startX);\n\n    // We don't know yet.\n    if (this.isSwiping === undefined) {\n      const dx = Math.abs(touch.pageX - this.startX);\n      const dy = Math.abs(touch.pageY - this.startY);\n\n      const isSwiping = dx > dy && dx > constant.UNCERTAINTY_THRESHOLD;\n\n      // We let the parent handle the scroll.\n      if (\n        !resistance &&\n        (axis === 'y' || axis === 'y-reverse') &&\n        ((this.indexCurrent === 0 && this.startX < touch.pageX) ||\n          (this.indexCurrent === React.Children.count(this.props.children) - 1 &&\n            this.startX > touch.pageX))\n      ) {\n        this.isSwiping = false;\n        return;\n      }\n\n      // We are likely to be swiping, let's prevent the scroll event.\n      if (dx > dy) {\n        event.preventDefault();\n      }\n\n      if (isSwiping === true || dy > constant.UNCERTAINTY_THRESHOLD) {\n        this.isSwiping = isSwiping;\n        this.startX = touch.pageX; // Shift the starting point.\n\n        return; // Let's wait the next touch event to move something.\n      }\n    }\n\n    if (this.isSwiping !== true) {\n      return;\n    }\n\n    // We are swiping, let's prevent the scroll event.\n    event.preventDefault();\n\n    // Low Pass filter.\n    this.vx = this.vx * 0.5 + (touch.pageX - this.lastX) * 0.5;\n    this.lastX = touch.pageX;\n\n    const { index, startX } = computeIndex({\n      children,\n      resistance,\n      pageX: touch.pageX,\n      startIndex: this.startIndex,\n      startX: this.startX,\n      viewLength: this.viewLength,\n    });\n\n    // Add support for native scroll elements.\n    if (nodeWhoClaimedTheScroll === null && !ignoreNativeScroll) {\n      console.log(\"native scroll elements\");\n      const domTreeShapes = getDomTreeShapes(event.target, this.rootNode);\n      const hasFoundNativeHandler = findNativeHandler({\n        domTreeShapes,\n        startX: this.startX,\n        pageX: touch.pageX,\n        axis,\n      });\n\n      // We abort the touch move handler.\n      if (hasFoundNativeHandler) {\n        return;\n      }\n    }\n\n    // We are moving toward the edges.\n    if (startX) {\n      this.startX = startX;\n    } else if (nodeWhoClaimedTheScroll === null) {\n      nodeWhoClaimedTheScroll = this.rootNode;\n    }\n\n    this.setIndexCurrent(index);\n\n    const callback = () => {\n      if (onSwitching) {\n        onSwitching(index, 'move');\n      }\n    };\n\n    if (this.state.displaySameSlide || !this.state.isDragging) {\n      this.setState(\n        {\n          displaySameSlide: false,\n          isDragging: true,\n        },\n        callback,\n      );\n    }\n\n    callback();\n  };\n\n  handleSwipeEnd = () => {\n    nodeWhoClaimedTheScroll = null;\n\n    // The touch start event can be cancel.\n    // Makes sure that a starting point is set.\n    if (!this.started) {\n      return;\n    }\n\n    this.started = false;\n\n    if (this.isSwiping !== true) {\n      return;\n    }\n\n    const indexLatest = this.state.indexLatest;\n    const indexCurrent = this.indexCurrent;\n    const delta = indexLatest - indexCurrent;\n\n    let indexNew;\n\n    // Quick movement\n    if (Math.abs(this.vx) > this.props.threshold) {\n      if (this.vx > 0) {\n        indexNew = Math.floor(indexCurrent);\n      } else {\n        indexNew = Math.ceil(indexCurrent);\n      }\n    } else if (Math.abs(delta) > this.props.hysteresis) {\n      // Some hysteresis with indexLatest.\n      indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);\n    } else {\n      indexNew = indexLatest;\n    }\n\n    const indexMax = React.Children.count(this.props.children) - 1;\n\n    if (indexNew < 0) {\n      indexNew = 0;\n    } else if (indexNew > indexMax) {\n      indexNew = indexMax;\n    }\n\n    this.setIndexCurrent(indexNew);\n    this.setState(\n      {\n        indexLatest: indexNew,\n        isDragging: false,\n      },\n      () => {\n        if (this.props.onSwitching) {\n          this.props.onSwitching(indexNew, 'end');\n        }\n\n        if (this.props.onChangeIndex && indexNew !== indexLatest) {\n          this.props.onChangeIndex(indexNew, indexLatest, {\n            reason: 'swipe',\n          });\n        }\n\n        // Manually calling handleTransitionEnd in that case as isn't otherwise.\n        if (indexCurrent === indexLatest) {\n          this.handleTransitionEnd();\n        }\n      },\n    );\n  };\n\n  handleTouchStart = event => {\n    if (this.props.onTouchStart) {\n      this.props.onTouchStart(event);\n    }\n    this.handleSwipeStart(event);\n  };\n\n  handleTouchEnd = event => {\n    if (this.props.onTouchEnd) {\n      this.props.onTouchEnd(event);\n    }\n    this.handleSwipeEnd(event);\n  };\n\n  handleMouseDown = event => {\n    if (this.props.onMouseDown) {\n      this.props.onMouseDown(event);\n    }\n    event.persist();\n    this.handleSwipeStart(adaptMouse(event));\n  };\n\n  handleMouseUp = event => {\n    if (this.props.onMouseUp) {\n      this.props.onMouseUp(event);\n    }\n    this.handleSwipeEnd(adaptMouse(event));\n  };\n\n  handleMouseLeave = event => {\n    if (this.props.onMouseLeave) {\n      this.props.onMouseLeave(event);\n    }\n\n    // Filter out events\n    if (this.started) {\n      this.handleSwipeEnd(adaptMouse(event));\n    }\n  };\n\n  handleMouseMove = event => {\n    if (this.props.onMouseMove) {\n      this.props.onMouseMove(event);\n    }\n\n    // Filter out events\n    if (this.started) {\n      this.handleSwipeMove(adaptMouse(event));\n    }\n  };\n\n  handleScroll = event => {\n    if (this.props.onScroll) {\n      this.props.onScroll(event);\n    }\n\n    // Ignore events bubbling up.\n    if (event.target !== this.rootNode) {\n      return;\n    }\n\n    if (this.ignoreNextScrollEvents) {\n      this.ignoreNextScrollEvents = false;\n      return;\n    }\n\n    const indexLatest = this.state.indexLatest;\n    const indexNew = Math.ceil(event.target.scrollLeft / event.target.clientWidth) + indexLatest;\n\n    this.ignoreNextScrollEvents = true;\n    // Reset the scroll position.\n    event.target.scrollLeft = 0;\n\n    if (this.props.onChangeIndex && indexNew !== indexLatest) {\n      this.props.onChangeIndex(indexNew, indexLatest, {\n        reason: 'focus',\n      });\n    }\n  };\n\n  updateHeight = () => {\n    if (this.activeSlide !== null) {\n      const child = this.activeSlide.children[0];\n      if (\n        child !== undefined &&\n        child.offsetHeight !== undefined &&\n        this.state.heightLatest !== child.offsetHeight\n      ) {\n        this.setState({\n          heightLatest: child.offsetHeight,\n        });\n      }\n    }\n  };\n\n  handleTransitionEnd() {\n    if (!this.props.onTransitionEnd) {\n      return;\n    }\n\n    // Filters out when changing the children\n    if (this.state.displaySameSlide) {\n      return;\n    }\n\n    // The rest callback is triggered when swiping. It's just noise.\n    // We filter it out.\n    if (!this.state.isDragging) {\n      this.props.onTransitionEnd();\n    }\n  }\n\n  render() {\n    const {\n      action,\n      animateHeight,\n      animateTransitions,\n      axis,\n      children,\n      containerStyle: containerStyleProp,\n      disabled,\n      disableLazyLoading,\n      enableMouseEvents,\n      hysteresis,\n      ignoreNativeScroll,\n      index,\n      onChangeIndex,\n      onSwitching,\n      onTransitionEnd,\n      resistance,\n      slideStyle: slideStyleProp,\n      slideClassName,\n      springConfig,\n      style,\n      threshold,\n      ...other\n    } = this.props;\n\n    const {\n      displaySameSlide,\n      heightLatest,\n      indexLatest,\n      isDragging,\n      renderOnlyActive,\n    } = this.state;\n    const touchEvents = !disabled\n      ? {\n          onTouchStart: this.handleTouchStart,\n          onTouchEnd: this.handleTouchEnd,\n        }\n      : {};\n    const mouseEvents =\n      !disabled && enableMouseEvents\n        ? {\n            onMouseDown: this.handleMouseDown,\n            onMouseUp: this.handleMouseUp,\n            onMouseLeave: this.handleMouseLeave,\n            onMouseMove: this.handleMouseMove,\n          }\n        : {};\n\n    // There is no point to animate if we are already providing a height.\n    warning(\n      !animateHeight || !containerStyleProp || !containerStyleProp.height,\n      `react-swipeable-view: You are setting animateHeight to true but you are\nalso providing a custom height.\nThe custom height has a higher priority than the animateHeight property.\nSo animateHeight is most likely having no effect at all.`,\n    );\n\n    const slideStyle = Object.assign({}, styles.slide, slideStyleProp);\n\n    let transition;\n    let WebkitTransition;\n\n    if (isDragging || !animateTransitions || displaySameSlide) {\n      transition = 'all 0s ease 0s';\n      WebkitTransition = 'all 0s ease 0s';\n    } else {\n      transition = createTransition('transform', springConfig);\n      WebkitTransition = createTransition('-webkit-transform', springConfig);\n\n      if (heightLatest !== 0) {\n        const additionalTranstion = `, ${createTransition('height', springConfig)}`;\n        transition += additionalTranstion;\n        WebkitTransition += additionalTranstion;\n      }\n    }\n\n    const containerStyle = {\n      height: null,\n      WebkitFlexDirection: axisProperties.flexDirection[axis],\n      flexDirection: axisProperties.flexDirection[axis],\n      WebkitTransition,\n      transition,\n    };\n\n    // Apply the styles for SSR considerations\n    if (!renderOnlyActive) {\n      const transform = axisProperties.transform[axis](this.indexCurrent * 100);\n      containerStyle.WebkitTransform = transform;\n      containerStyle.transform = transform;\n    }\n\n    if (animateHeight) {\n      containerStyle.height = heightLatest;\n    }\n\n    return (\n      <div\n        ref={this.setRootNode}\n        style={Object.assign({}, axisProperties.root[axis], style)}\n        {...other}\n        {...touchEvents}\n        {...mouseEvents}\n        onScroll={this.handleScroll}\n      >\n        <div\n          ref={this.setContainerNode}\n          style={Object.assign({}, containerStyle, styles.container, containerStyleProp)}\n          className=\"react-swipeable-view-container\"\n        >\n          {React.Children.map(children, (child, indexChild) => {\n            if (renderOnlyActive && indexChild !== indexLatest) {\n              return null;\n            }\n\n            console.log(\"indexChild =\", indexChild); \n\n            warning(\n              React.isValidElement(child),\n              `react-swipeable-view: one of the children provided is invalid: ${child}.\nWe are expecting a valid React Element`,\n            );\n\n            let ref;\n            let hidden = true;\n\n            if (indexChild === indexLatest) {\n              hidden = false;\n\n              if (animateHeight) {\n                ref = this.setActiveSlide;\n                slideStyle.overflowY = 'hidden';\n              }\n            }\n\n            return (\n              <div\n                ref={ref}\n                style={slideStyle}\n                className={slideClassName}\n                aria-hidden={hidden}\n                data-swipeable=\"true\"\n              >\n                {child}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\n// Added as an ads for people using the React dev tools in production.\n// So they know, the tool used to build the awesome UI they\n// are looking at/retro engineering.\nSwipeableViews.displayName = 'ReactSwipableView';\n\nSwipeableViews.propTypes = {\n  /**\n   * This is callback property. It's called by the component on mount.\n   * This is useful when you want to trigger an action programmatically.\n   * It currently only supports updateHeight() action.\n   *\n   * @param {object} actions This object contains all posible actions\n   * that can be triggered programmatically.\n   */\n  action: PropTypes.func,\n  /**\n   * If `true`, the height of the container will be animated to match the current slide height.\n   * Animating another style property has a negative impact regarding performance.\n   */\n  animateHeight: PropTypes.bool,\n  /**\n   * If `false`, changes to the index prop will not cause an animated transition.\n   */\n  animateTransitions: PropTypes.bool,\n  /**\n   * The axis on which the slides will slide.\n   */\n  axis: PropTypes.oneOf(['x', 'x-reverse', 'y', 'y-reverse']),\n  /**\n   * Use this property to provide your slides.\n   */\n  children: PropTypes.node.isRequired,\n  /**\n   * This is the inlined style that will be applied\n   * to each slide container.\n   */\n  containerStyle: PropTypes.object,\n  /**\n   * If `true`, it will disable touch events.\n   * This is useful when you want to prohibit the user from changing slides.\n   */\n  disabled: PropTypes.bool,\n  /**\n   * This is the config used to disable lazyloding,\n   * if `true` will render all the views in first rendering.\n   */\n  disableLazyLoading: PropTypes.bool,\n  /**\n   * If `true`, it will enable mouse events.\n   * This will allow the user to perform the relevant swipe actions with a mouse.\n   */\n  enableMouseEvents: PropTypes.bool,\n  /**\n   * Configure hysteresis between slides. This value determines how far\n   * should user swipe to switch slide.\n   */\n  hysteresis: PropTypes.number,\n  /**\n   * If `true`, it will ignore native scroll container.\n   * It can be used to filter out false positive that blocks the swipe.\n   */\n  ignoreNativeScroll: PropTypes.bool,\n  /**\n   * This is the index of the slide to show.\n   * This is useful when you want to change the default slide shown.\n   * Or when you have tabs linked to each slide.\n   */\n  index: PropTypes.number,\n  /**\n   * This is callback prop. It's call by the\n   * component when the shown slide change after a swipe made by the user.\n   * This is useful when you have tabs linked to each slide.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {integer} indexLatest This is the oldest index of the slide.\n   * @param {object} meta Meta data containing more information about the event.\n   */\n  onChangeIndex: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseDown: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseLeave: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseMove: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onMouseUp: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onScroll: PropTypes.func,\n  /**\n   * This is callback prop. It's called by the\n   * component when the slide switching.\n   * This is useful when you want to implement something corresponding\n   * to the current slide position.\n   *\n   * @param {integer} index This is the current index of the slide.\n   * @param {string} type Can be either `move` or `end`.\n   */\n  onSwitching: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchEnd: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchMove: PropTypes.func,\n  /**\n   * @ignore\n   */\n  onTouchStart: PropTypes.func,\n  /**\n   * The callback that fires when the animation comes to a rest.\n   * This is useful to defer CPU intensive task.\n   */\n  onTransitionEnd: PropTypes.func,\n  /**\n   * If `true`, it will add bounds effect on the edges.\n   */\n  resistance: PropTypes.bool,\n  /**\n   * This is the className that will be applied\n   * on the slide component.\n   */\n  slideClassName: PropTypes.string,\n  /**\n   * This is the inlined style that will be applied\n   * on the slide component.\n   */\n  slideStyle: PropTypes.object,\n  /**\n   * This is the config used to create CSS transitions.\n   * This is useful to change the dynamic of the transition.\n   */\n  springConfig: PropTypes.shape({\n    delay: PropTypes.string,\n    duration: PropTypes.string,\n    easeFunction: PropTypes.string,\n  }),\n  /**\n   * This is the inlined style that will be applied\n   * on the root component.\n   */\n  style: PropTypes.object,\n  /**\n   * This is the threshold used for detecting a quick swipe.\n   * If the computed speed is above this value, the index change.\n   */\n  threshold: PropTypes.number,\n};\n\nSwipeableViews.defaultProps = {\n  animateHeight: false,\n  animateTransitions: true,\n  axis: 'x',\n  disabled: false,\n  disableLazyLoading: false,\n  enableMouseEvents: false,\n  hysteresis: 0.6,\n  ignoreNativeScroll: false,\n  index: 0,\n  threshold: 5,\n  springConfig: {\n    duration: '0.35s',\n    easeFunction: 'cubic-bezier(0.15, 0.3, 0.25, 1)',\n    delay: '0s',\n  },\n  resistance: false,\n};\n\nSwipeableViews.childContextTypes = {\n  swipeableViews: PropTypes.shape({\n    slideUpdateHeight: PropTypes.func,\n  }),\n};\n\nexport default SwipeableViews;\n"]},"metadata":{},"sourceType":"module"}